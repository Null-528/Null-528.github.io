<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>详解gRPC协议(二)</title>
      <link href="/post/5a25e7f5.html"/>
      <url>/post/5a25e7f5.html</url>
      
        <content type="html"><![CDATA[<p>我们在之前的文章中介绍了gRPC协议使用的protobuf，从而定义gRPC service和具体用到的对象模型。这篇文章中，我们来具体通过gRPC来调用一个服务，看看gRPC是如何工作的。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解gRPC协议(一)Protobuf</title>
      <link href="/post/12cc1a39.html"/>
      <url>/post/12cc1a39.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是gRPC协议"><a href="#什么是gRPC协议" class="headerlink" title="什么是gRPC协议"></a>什么是gRPC协议</h1><p><a href="https://grpc.io/">gRPC</a> 是一个由Google开发的高性能开源的RPC框架，基于HTTP&#x2F;2协议标准设计，支持GO，C++，JAVA，Python等多种语言。我们之前已经介绍过了RPC框架，见<a href="https://null-528.github.io/post/b9eb0f9.html">详解RPC</a>，gRPC整体流程和RPC是完全一致的：</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/grpc%E8%B0%83%E7%94%A8.svg" alt="grpc调用"><br>gRPC使用谷歌自家开源的Protocol Buffers(protobuf)作为信息描述格式。因此我们需要先来学习一下protobuf。</p><h1 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h1><p>协议缓冲区Protobuf(Protocol Buffers)是一种免费开源的跨平台数据格式，用于序列化结构化数据。（From <a href="https://en.wikipedia.org/wiki/Protocol_Buffers">Wiki</a>）它与 JSON 或XML 类似，只是体积更小、速度更快，而且能生成本地语言绑定。</p><p>在通信管道上，protobuf 使用ASCII码，通过纯二进制的方式进行传输。由于其紧凑的数据结构，在传输数据时，能够节省带宽、提高传输性能，但同时也意味着相比 JSON 和 XML 这种字符文本形式，protobuf丧失了可读性，也就是说，如果没有外部规范文件.proto，就无法知道字段的名称、含义或完整数据类型。</p><p>由于上述特性，protobuf非常适合用于高效RPC传输的场景。发送端和接收端使用相同的一份.proto文件，发送端将数据通过.proto文件中定义的格式对数据进行序列化，然后发送给接收端，接收端通过.proto文件对数据进行反序列化。</p><h1 id="protobuf详解"><a href="#protobuf详解" class="headerlink" title="protobuf详解"></a>protobuf详解</h1><p>例如我们有一个后缀为 .proto 的普通文本文件，里面定义了Field对象的相关字段：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> xxx.proto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;xxx.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Field</span> &#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> metric = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> field = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Type</span> &#123;</span><br><span class="line">        IMAGES = <span class="number">0</span>;</span><br><span class="line">        WEB = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字段</th><th>含义</th></tr></thead><tbody><tr><td align="center">syntax</td><td>protobuf的版本，目前支持proto2和proto3，默认为proto2。在我们这篇文章中的case都使用proto3版本</td></tr><tr><td align="center">package</td><td>用来声明包避免命名冲突，如果使用的是JAVA，那么等效于java_package。</td></tr></tbody></table><blockquote><p>在不同的语言中都有不同option来定制化一些内容，例如java还有：</p><ul><li>java_multiple_files：默认为false。设置是否生成多个文件，如果为true，那么每个message对象都会生成一个.java文件。</li><li>java_outer_classname：在单文件的情况下，设置生成的.java文件名称，即多个message对象的外部类名称。如果没有设置的话，会将.proto文件名的驼峰写法作为文件名。</li><li>java_generate_equals_and_hash：默认false，设置是否生成equals和hashCode方法。</li><li>java_generic_services：默认false，设置是否生成泛型服务。</li></ul><p> 其他语言中也有对应的option，例如：</p><ul><li>csharp_namespace：设置C#的命名空间。</li><li>go_package：设置Go的包名。</li><li>py_generic_services：默认false，设置是否开启Python的泛型服务。</li><li>ruby_package：设置Ruby的包名。</li></ul><p>需要注意，proto2和proto3具体option是有区别的，具体可以参考[官方文档](<a href="https://developers.google.com/protocol-buffers/docs/proto%EF%BC%89">https://developers.google.com/protocol-buffers/docs/proto）</a></p></blockquote><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>很多标准的简单数据类型供字段可用，常用的有double、float、uint32、uint64、bool、string、bytes、uint32、uint64、enum以及其他在文件中定义的message类型。</p><ul><li>int32、int64：如果负数指定这两个类型编码效率较低。负数应该使用下面的类型。</li><li>sint32、sint64：对负数会进行ZigZag编码提高编码效率。</li><li>fixed32、fixed64：总是4字节和8字节</li><li>sfixed32、sfixed64：总是4字节和8字节</li><li>enum：枚举类型，对应的字段编号必须从0开始，其对应的枚举值会作为默认值。</li></ul><p>因为采用Varint编码4个字节能表示的最大数字就是228-1了，超过这个值就需要5个字节来表示。因此对于大于228-1的数，采用固定长度fixed32或者fixed64的效率会更高。</p><h2 id="字段编号"><a href="#字段编号" class="headerlink" title="字段编号"></a>字段编号</h2><p>需要给每一个字段赋予一个整数作为编号，用来唯一指定二进制中的field。传输的时候只会使用这个编号，具体的信息，如字段名称、类型等，是通过传输双方共有的.proto文件来确定的。这样就节省了一些带宽空间，也避免了不同语言中表示字段类型大小不同的冲突。</p><p>所以编号一旦正式使用就不支持修改,<strong>否则就相当于删除了这个字段，然后创建了一个相同类型但不同编号的新字段</strong>。就算真的要删除这个字段，这个字段在使用时忽略即可，不要删除，否则可能导致新增字段不小心重复编号。</p><p>使用限制：</p><ol><li>给定的编号在该对象的所有字段中必须是唯一的。</li><li>字段编号 19,000 至 19,999 保留给协议缓冲区实现。如果在报文中使用了这些保留字段编号，协议缓冲区编译器将发出报警。<blockquote><p>一般我们会从1开始依次递增+1编号，因为较低的字段编号传输时中占用的空间较少。例如，字段编号范围为 1 至 15 的字段编号只需一个字节进行编码。16 至 2047 范围内的字段编号需要两个字节。</p></blockquote></li></ol><h2 id="字段规则"><a href="#字段规则" class="headerlink" title="字段规则"></a>字段规则</h2><p>目前支持optional和required、repeated。</p><ul><li>optional表示该字段非必填，可以为空。</li><li>required表示该字段必填，不能为空。</li><li>repeated表示该字段可以重复多次，包括零次，相当于数组。</li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>上面代码已经体现，protobuf的数据结构格式（schema）叫做message，它表示定义一个对象,一个消息(message)是包含一系列类型字段的k-v对。想象我们需要将这些数据序列化为二进制串，那么需要知道每个字段对应的起止位置、名称和对应的值。</p><p>所以<strong>报文的二进制版本会将字段编号作为键，解码端通过.proto文件来确定每个字段的名称和声明类型。</strong>即以T-L-V（Tag - Length - Value）表示单个字段field，最终将所有数据拼接成一个紧凑的字节流：</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/TLV.webp" alt="protobuf使用的TLV"></p><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>先来看Tag，它由两部分组成，最后整体通过Varints编码：</p><ul><li>field_number：字段编号，见1.1.2节。</li><li>wire_type：protobuf编码类型，目前protobuf定义了6种，见上表（其中Start group和End group已经被废弃）。序列化和反序列化时会选择对应的编码方式，编码对象为最终的Value。</li></ul><p>tag至少占用一个1字节，如果field_number大于15，那么需要多占用2个字节。其中最高位用于Varint编码保留，确认下一个字节是否需要。另外wire_type占用4个bit，field_number占用剩余的bit。</p><h3 id="Length-Value"><a href="#Length-Value" class="headerlink" title="Length &amp; Value"></a>Length &amp; Value</h3><p>length表示Value的长度，但并不是必填，可以根据message使用的数据类型来判断value长度。<strong>但如果tag中选择wire_type为Length-delimited，那么表示value是变长的数据类型，如string，所以length是必填的。</strong></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>前文提过，protobuf现在支持的编码方式只有4种，分别是Varint、Fixed32、Fixed64和Length-delimited。对于文本类型，直接根据ASCII码转为二进制即可，但对数字类型稍微复杂些：</p><h3 id="Varint"><a href="#Varint" class="headerlink" title="Varint"></a>Varint</h3><p>Varint编码方式是最常用的数字编码方式，举个例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int32 a = 251;</span><br><span class="line"></span><br><span class="line">数字251的二进制补码表示为：</span><br><span class="line">0000 0000 0000 0000 0000 0000 1111 1011</span><br><span class="line"></span><br><span class="line">使用varint编码：</span><br><span class="line">1.以7位1组单位逆序：</span><br><span class="line">111 1011 000 0001 0000 0000 0000 0000 00</span><br><span class="line"></span><br><span class="line">2.7位1组，第一位高位为msb(most significant bit)表示是否需要下一个字节，这里第一个字节需要下一个字节，故第一个字节补高位为1。第二个字节不需要第三个字节了，故第二个字节补高位为0</span><br><span class="line">1111 1011 0000 0001 0000 0000 0000 0000 00</span><br><span class="line"></span><br><span class="line">故数字251的varint编码为：</span><br><span class="line">1111 1011 0000 0001</span><br><span class="line"></span><br><span class="line">十六进制表示为：</span><br><span class="line">0xFB01</span><br></pre></td></tr></table></figure><p>可以看到，每个字节中的最高位都需要保留，因此4个字节最多可以表示2^28-1，超过这个数就需要增加一个字节，降低一定编码效率。</p><h3 id="ZigZag"><a href="#ZigZag" class="headerlink" title="ZigZag"></a>ZigZag</h3><p>另外，容易想到，如果要表示的负数，原来的最高位是符号位，这样就发生了冲突，或者占用2个bit就进一步压缩了能表示的数字范围，会有更大的几率需要增加额外字节，因此Varint编码方式只适用于正数，对于负数，需要使用ZigZag编码，<strong>有符号整数映射到无符号整数，然后再使用 Varints 编码。</strong>映射关系为：</p><ul><li>Zigzag(n) &#x3D; (n &lt;&lt; 1) ^ (n &gt;&gt; 31),  n为sint32时</li><li>Zigzag(n) &#x3D; (n &lt;&lt; 1) ^ (n &gt;&gt; 63),  n为sint64时</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = -1;</span><br><span class="line"></span><br><span class="line">-1的二进制编码：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">n &lt;&lt; 1后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line"></span><br><span class="line">n &gt;&gt; 31后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">故(n &lt;&lt; 1) ^ (n &gt;&gt; 31)后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111----两行执行不进位的半加操作</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">故:Zigzag(-1) = 1;</span><br></pre></td></tr></table></figure><h2 id="反序列化解析"><a href="#反序列化解析" class="headerlink" title="反序列化解析"></a>反序列化解析</h2><p>那么对于一整个message结构体:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个根据这个.proto文件生成的二进制串：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">十六进制：</span><br><span class="line">0a06 5374 6576 656e</span><br><span class="line"></span><br><span class="line">二进制表示为：</span><br><span class="line">00001010 00000110 01010011 01110100 01100101 01110110 01100101 01101110</span><br></pre></td></tr></table></figure><p>先分析前两个字节，在这个case中即tag和length</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/deserialize.png"></p><p>再来看value，即后面的6个字节，分别对应ASCII码：<code>83 116 101 118 101 110</code>，对照ASCII码表得到的字符串为： <code>Steven</code>。</p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>除了message之外，proto文件中还可以定义service，用来定义远程调用的方法：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">Computer</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ping (Empty) <span class="keyword">returns</span> (ServerStatus) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> compute (stream ComputeRequest) <span class="keyword">returns</span> (stream ComputeResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的service中定义了两个方法，我们分别来看一下：</p><h2 id="简单rpc"><a href="#简单rpc" class="headerlink" title="简单rpc"></a>简单rpc</h2><p>ping()方法，参数为Empty，返回值为ServerStatus。具体这两个对象需要在.proto文件中去详细定义。整个过程和平常的函数调用一样。</p><h2 id="流式rpc"><a href="#流式rpc" class="headerlink" title="流式rpc"></a>流式rpc</h2><p>注意到第二个方法，compute()，参数为stream ComputeRequest，返回值为stream ComputeResponse。通过在参数和返回值前加上stream关键字，表示这是一个流式rpc。</p><ul><li>如果只在入参部分使用stream关键字，说明是一个客户端流式RPC，即客户端使用流将一个消息序列发送给服务端，然后服务端返回一个响应；</li><li>反过来，如果只在返回值部分使用stream关键字，说明是一个服务端流式RPC，即客户端在发送请求后，使用流从服务端获取响应，直到流中没有其他消息为止。</li><li>如果同时使用stream关键字，则表示双向流式RPC，即客户端和服务端都使用流将消息序列发送和接收。这两个流是独立操作的，因此客户端和服务器可以按任意顺序发送和接收消息。比如：服务器可以在写入响应前等待接收到所有的请求消息，或者可以交替读取和写入消息，或者以任何顺序读取和写入。</li></ul><h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><p>可以看到，message这种结构体在传输时，需要一次性加载到内存中进行解析，因此只适合用于传输几兆字节的小数据块，如果报文太大，应该考虑其他的方法，比如流式传输。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA调式技巧</title>
      <link href="/post/f3b3a2f5.html"/>
      <url>/post/f3b3a2f5.html</url>
      
        <content type="html"><![CDATA[<h1 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h1><p>当我们需要数据一个新的服务代码，例如了解cassandra的启动流程，如果只看代码很容易遗漏一些细节，这个时候可以通过远程调试，一步步来跟踪代码，查看服务运行情况。</p><ol><li><p>调整debug configuration，添加远程debug参数<br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/1.jpg"><br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/2.jpg"><br>需要修改的参数：<br>①Host: 如果是本地启动的服务，可以填写localhost，否则填写服务ip<br>②Port: 调试端口，注意不要和服务器端的端口冲突。<br>另外注意公司可能做了端口拦截或防火墙，要保证本地服务是能访问到调试的ip+port。</p></li><li><p>在启动服务的入口添加参数<br>例如cassandra，是通过bin&#x2F;cassandra脚本，执行launch_server方法启动的。我们在脚本中将上面remote JVM参数添加到java启动命令中。其中需要将断点syspend改为y，否则不会在我们打的断点处停下来。<br> 完整命令类似于：</p> <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=trans<span class="keyword">port</span>=dt_socket,server=y,suspend=y,address=5005</span><br></pre></td></tr></table></figure><p>在脚本中修改后类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="variable">$NUMACTL</span> <span class="string">&quot;<span class="variable">$JAVA</span>&quot;</span> <span class="variable">$JVM_OPTS</span> -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y,address=5005 <span class="variable">$cassandra_parms</span> -<span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$CLASSPATH</span>&quot;</span> <span class="variable">$props</span> <span class="string">&quot;<span class="variable">$class</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>启动服务，等待debug连接<br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/3.jpg"><br>现在IDEA中点击debug按钮，监听远程服务断点，然后我们执行脚本启动服务，然后就可以在IDEA中调试服务了。</p></li><li><p>本地测试作为远程服务<br>当遇到一些集成测试，可能发生case间影响的时候，也可以尝试用这样的方法来调试。唯一不同的就是我们启动单测的方式：<br>对于mvn，可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean verify -Pjacoco -Dtest.env.runningMode=multi  -Dtest=&quot;&quot;  </span><br></pre></td></tr></table></figure><p>对于gradle，则可以执行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./gradlew</span> <span class="params">--info</span> :&#123;submodule&#125;<span class="function">:test</span> <span class="params">--tests=</span><span class="string">&quot;&quot;</span> -Dorg.gradle.debug=<span class="literal">true</span> <span class="params">--debug-jvm</span></span><br></pre></td></tr></table></figure><p>例如，单跑1个case：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --info :iot-tsdb-data-unit-test:test --tests=<span class="string">&quot;xxx.MysqlConnectorJTest&quot;</span> --debug-jvm</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解RPC</title>
      <link href="/post/b9eb0f9.html"/>
      <url>/post/b9eb0f9.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>在最早的时候，进程只能获取自己栈帧内的数据，例如有2个进程，两者是无法数据通信的。为了解决这个问题，出现了本地进程间通信IPC（Inter-Process Communication）技术，通过如共享内存，管道等手段，来交换数据。但后来业务逐渐复杂，磁盘、CPU等资源逐渐达到瓶颈，人们开始考虑将多台计算机组成一个集群来提高服务的吞吐能力，这就是分布式。</p><p>RPC（Remote Procedure Call），即远程程序调用，可以理解为RPC是将进程间通信的范围从单机扩大到了一个共享网络中，这样不同服务间调用方法像同一服务间调用本地方法一样，而不需要调用者了解底层网络技术的协议。如cassandra集群节点接通信，以及SpringCloud 微服务中各个服务之间的通信。</p><p>RPC 现在所指的概念也有些模糊，一般来说我们将其理解为一种request-response的网络传输思想，但在wiki等一些网站上，rpc也可以狭义地理解为一种协议，并且需要通过stub等动态代理来实现消息传输。</p><h1 id="RPC协议模型"><a href="#RPC协议模型" class="headerlink" title="RPC协议模型"></a>RPC协议模型</h1><p>这里介绍在wiki等网站<strong>狭义</strong>定义的RPC协议模型：<br><img src="/../images/%E8%AF%A6%E8%A7%A3RPC/rpc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpeg" alt="rpc调用"><br>整个过程可以分为以下几个阶段：</p><ol><li>客户机调用本地的Stub，将参数传递进去。</li><li>Stub将参数marshall（打包）到消息中。这个过程包括将参数标准化的过程。</li><li>Stub将消息传递给传输层，再由传输层发送到远程服务器机器。</li><li>服务器的Stub收到消息后，存根对参数进行unmarshall（解包），然后根据参数调用本地服务。</li><li>服务器服务完成调用后，将结果参数返回给服务器Stub，服务器Stub再将结果参数标准化并marshall（打包）到消息中。</li><li>服务器Stub将消息传递给传输层，传输层再发送给客户端Stub。</li><li>客户端Stub解析参数，将结果返回给调用者。</li></ol><p>在上面的流程中，看上去两个进程是1对1同步阻塞的，但实际上rpc并没有限制异步调用，可以选择异步来提高并发。</p><blockquote><p>这里用Stub存根来指代远程服务的本地代理程序或者软件，它是客户端和应用程序的中间层，用于处理一些调用细节如负责封装请求、解析响应、处理网络通信等。例如在java中，Stab就是通过动态代理技术实现的。</p><p>Stub一般都是RPC框架自动生成的，开发者不需要关心。</p></blockquote><h1 id="RPC系统"><a href="#RPC系统" class="headerlink" title="RPC系统"></a>RPC系统</h1><p>为了让不同的客户端访问服务器，人们创建了许多标准化的 RPC 框架。这些框架大多使用接口描述语言IDL(Interface description language)来让各种平台调用 RPC。IDL 文件随后可用于生成客户端与服务器之间的接口代码。目前有以下这些常见的 RPC 框架：</p><ol><li><p>gRPC：由Google开发的高性能、跨语言的RPC框架，基于HTTP&#x2F;2协议，支持多种语言，如C++, Java, Python, Go等。gRPC使用Protocol Buffers作为默认的序列化协议，支持双向流、流式处理等特性。</p></li><li><p>Apache Thrift：由Facebook开发的跨语言的RPC框架，支持多种语言，如C++, Java, Python, PHP等。Thrift使用自定义的IDL（Interface Definition Language）来定义服务接口，支持多种传输协议和序列化协议。如cassandra执行cql时使用的就是Thrift。</p></li><li><p>Apache Dubbo：由阿里巴巴开发的高性能、轻量级的RPC框架，支持多种语言，如Java, Go, Python等。Dubbo提供了丰富的功能，如负载均衡、服务注册与发现、服务治理等。但官网的性能测试数据可能并不准确，实际使用中性能表现不如gRPC，可以参考<a href="https://coolshell.cn/articles/17381.html">性能测试应该怎么做？</a></p></li></ol><h1 id="其他常见概念"><a href="#其他常见概念" class="headerlink" title="其他常见概念"></a>其他常见概念</h1><h2 id="Restful-RPC"><a href="#Restful-RPC" class="headerlink" title="Restful &amp; RPC"></a>Restful &amp; RPC</h2><p>两者不是可以放在一起比较的概念。<br>Restful，即 Representational State Transfer(表现层状态转移)，是一种设计风格，它面向资源，对接口做出了一系列要求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取所有用户： GET /users</span><br><span class="line">获取指定用户： GET /users/&#123;<span class="built_in">id</span>&#125;</span><br><span class="line">创建用户：    POST /users</span><br><span class="line">更新用户：    PUT /users/&#123;<span class="built_in">id</span>&#125;</span><br><span class="line">删除用户：    DELETE /users/&#123;<span class="built_in">id</span>&#125;</span><br></pre></td></tr></table></figure><p>从宏观来讲，RPC是一种网络通信思想，而Restful是一种API规范。RPC本身并不限制实现框架的传输协议，只要是基于传输层之上的就可以。但Restful一定都是作用于HTTP&#x2F;HTTPS协议之上的。</p><h2 id="MQTT-RPC"><a href="#MQTT-RPC" class="headerlink" title="MQTT &amp; RPC"></a>MQTT &amp; RPC</h2><p>从定义来讲，MQTT的发布订阅模式并不完全符合RPC『远程程序调用』的定义，即MQTT的接收方不会返回调用运行计算结果。笔者认为这应该是两种网络通信方式。<br>另外，从定义来讲，RPC要求调用方和被调用方必须同时存在，而MQTT是发布订阅模式，即消息的发送者不需要知道消息接收者的存在。PC是一对一，MQTT是多对一。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础系列】代理</title>
      <link href="/post/53c8b77c.html"/>
      <url>/post/53c8b77c.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h1><p>   在编译时期无法确定需要实现哪个接口时，我们可以使用代理，在运行时创建实现一组给定接口的新类。对于编写应用程序的程序员来说这种场景比较少见，但对某些系统应用程序，代理带来的灵活性十分重要。</p><p>   总体来说，代理就是为某些对象的某种行为提供一个代理对象，并由代理对象完全控制该行为的实际执行。代理分为静态代理和动态代理两类，两者的主要区别就是代理类生成的时机，其中：</p><ul><li>静态代理：在程序运行前，创建代理类，实现代理逻辑，编译时就已经实现了，编译完成后代理类成为一个实际的class文件。</br></li><li>动态代理：在程序运行时，运用反射机制动态创建代理类，编译时没有实际的class文件，而是在运行时动态生成字节码。</br></li></ul><p>特别地，动态代理又有两种主要的实现方式，分别为：JDK 动态代理和 CGLIB 动态代理。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>   当我们需要在不修改目标对象的前提下，扩展目标对象的功能，就可以使用静态代理。例如：</p><p>我们有一个接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个目标对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDao</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们的静态代理对象可以这么构建，可以看出，静态Proxy相当于将要代理的对象封装了一层，重写并嵌套使用其所有的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IHello target；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(IHello target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">        target.sayHello();</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>   假如我们要构造一个类的对象，这个类实现了1个或多个接口，但在编译时期，可能并不知道这些接口是什么，这个时候就可以使用动态代理来解决我们的问题。动态代理有两大类：JDK和CGLIB，两者最大的不同是JDK需要代理的对象是基于接口实现的，而CGLIB作为第三方代码生成的类库，没有这种需求。</p><p>   动态代理基本会代理所有的代理对象的方法,对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发，例如getClass()、clone()方法。 </p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>   JDK 动态代理就是基于 JDK 实现的代理模式，主要运用了其拦截器和反射机制，其代理对象是由 JDK 动态生成的，而不像静态代理方式写死代理对象和被代理类。JDK 代理是不需要第三方库支持的，只需要 JDK 环境就可以进行代理，使用条件：</p><ul><li>必须实现InvocationHandler</li><li>使用Proxy.newProxyInstance产生代理对象</li><li>被代理的对象必须实现一个或多个接口</li></ul><blockquote><p>使用 JDK 动态代理的五大步骤：</br><br>1.通过实现InvocationHandler接口来定义自己的InvocationHandler</br><br>2.通过Proxy.getProxyClass获得动态代理类</br><br>3.通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)</br><br>4.通过构造函数获得代理对象并将自定义的InvocationHandler实例对象为参数传入</br><br>5.通过代理对象调用目标方法。</br></p></blockquote><p>  接下来，我们就按上面的 5 个步骤，写一个 JDK 动态代理的示例。</p><ul><li>PersonProxyFactory，HelloImpl的代理类，这个代理类中需要实现InvocationHandler接口的invoke方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IHello <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> invocationHandler();</span><br><span class="line">        <span class="comment">// 传入代理目标使用的类加载器、代理目标实现的接口类型、对应的事件处理器。</span></span><br><span class="line">        <span class="keyword">return</span> (IHello) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InvocationHandler <span class="title function_">invocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现InvocationHandler接口的invoke方法</span></span><br><span class="line">        <span class="keyword">return</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(instance, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>MyProxyTest，测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PersonProxyFactory</span> <span class="variable">personProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxyFactory</span>(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">        personProxyFactory.createProxy().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。它广泛地被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</p><p>还是之前的几个例子，我们实现CGLIB的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibPersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CGLibPersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB HELLO WORLD !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>在动态代理的过程中，如果被代理的对象的执行方法抛错，调用方会得到InvocationTargetException类的异常，这个异常封装了实际的问题，需要使用getTargetException()方法将内容取出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/post/3c50d03d.html"/>
      <url>/post/3c50d03d.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Markdown 由 John Gruber 和 Aaron Swartz 于 2004 年创建，目标是创造一种web文本格式，尽可能方便人们阅读和写作。但起初它的设计主要针对一些简单日常的使用场景，并支持用户通过内联html来支持未涵盖到的语法，见<a href="https://daringfireball.net/projects/markdown/syntax">Markdown基本语法</a>。后来一些个人和组织开始通过添加其他元素来扩展基本语法，很多的Markdown处理器使用的都是拓展后的语言，例如Typora 使用的是<a href="https://github.github.com/gfm/">GitHub Flavored Markdown(GFM)</a>。</p><blockquote><p>John Gruber（1973-？） 是一个美国宾夕法尼亚州的技术博主，也是苹果公司的狂热粉丝，后来通过全职运行他的独立博客<a href="https://daringfireball.net/">Daring Fireball</a>，和有声杂志The talk show，分享他的技术见解和苹果产品的最新消息和点评。</p></blockquote><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>通过不同个数的『#』来设置标题，最多支持六级标题。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br><span class="line">####### 不支持七级标题</span><br></pre></td></tr></table></figure><p>其中，一级和二级标题还有一种写法：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">===================</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">--------------------</span></span><br></pre></td></tr></table></figure><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>一般段落，通过换行来创建即可。在idea中可以通过setting-&gt;editor-&gt;general-&gt;soft wrap来设置全局自动换行。有需要强制换行的，通过在行尾添加<code>&lt;/br&gt;</code>来强制换行。</br><br>另外，段落<strong>不支持</strong>使用空格或tab来缩进。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>通过<code>&gt;</code>来进行块引用，支持嵌套。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">这是一层引用</span></span><br><span class="line">&gt;&gt; 这是二层引用（后面空一行表示结束第一层引用）</span><br><span class="line"><span class="meta prompt_">&gt;</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">回到第一层引用</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">### 可以添加*标题*</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">- 和其他元素</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这是一层引用</p><blockquote><p>这是二层引用</p></blockquote><p>回到第一层引用</p><h3 id="可以添加标题"><a href="#可以添加标题" class="headerlink" title="可以添加标题"></a>可以添加标题</h3><ul><li>和其他元素，但是是否渲染以及渲染效果取决于使用的解析器。</li></ul></blockquote><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>无序列表通过<code>-</code>、<code>+</code>或<code>*</code>来创建，支持嵌套。有序列表通过数字加<code>.</code>来创建，支持嵌套和相互嵌套。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是无序列表</span><br><span class="line"><span class="bullet">-</span> 无序1</span><br><span class="line"><span class="bullet">    -</span> 嵌套1</span><br><span class="line"><span class="bullet">+</span> 无序2</span><br><span class="line"><span class="bullet">*</span> 无序3</span><br><span class="line">这是有序列表</span><br><span class="line"><span class="bullet">1.</span> 有序1</span><br><span class="line"><span class="bullet">   1.</span> 嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)</span><br><span class="line"><span class="bullet">      -</span> 无序和有序可以相互嵌套</span><br><span class="line"><span class="bullet">2.</span> 有序2</span><br></pre></td></tr></table></figure><p>效果：</br><br>这是无序列表</p><ul><li>无序1<ul><li>嵌套1</li></ul></li></ul><ul><li>无序2</li></ul><ul><li>无序3</li></ul><blockquote><p>一般来说，同一个列表中最好不要混用不同的分隔符，否则有些解析器可能会识别混乱造成渲染错误。</p></blockquote><p></br>这是有序列表</p><ol><li>有序1<ol><li>嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)<ul><li>无序和有序可以相互嵌套</li></ul></li></ol></li><li>有序2</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>通过反引号『&#96;』来创建行内代码，不支持嵌套。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`hello world!`</span></span><br></pre></td></tr></table></figure><p>效果：<code>hello world!</code><br/><br>一般情况下我们都使用反斜杠<code>\</code>进行转义，但特别地，如果要对反引号进行转义，需要通过双反引号。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">``Use `code` in your Markdown file.``</span><br><span class="line">`` `hello world!` ``</span><br></pre></td></tr></table></figure><p>效果：<code>Use `code` in your Markdown file.</code> <code>`hello world!`</code> </p><p>通过前后2个『&#96;&#96;&#96;』来创建封闭的代码块，在起始的三个”&#96;”后可以表明使用的语言（小写），来进行语法高亮。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHello</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法高亮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>使用<code>*</code>或<code>_</code>来设置斜体，使用<code>**</code>或<code>__</code>来设置加粗，使用<code>***</code>或<code>___</code>来设置斜体加粗，使用<code>~~</code>来设置删除线。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*斜体*</span></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="emphasis">__加粗__</span></span><br><span class="line"><span class="strong">***斜体加粗**</span>*</span><br><span class="line"><span class="emphasis">___斜体加粗__</span>_</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：<br><em>斜体</em><br><em>斜体</em><br><strong>加粗</strong><br><strong>加粗</strong><br><em><strong>斜体加粗</strong></em><br><em><strong>斜体加粗</strong></em><br><del>删除线</del></p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="外部url直接引用"><a href="#外部url直接引用" class="headerlink" title="外部url直接引用"></a>外部url直接引用</h2><p>通过&lt;&gt;可以直接创建外部引用链接。如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:<span class="comment">//baidu.com/&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<a href="https://baidu.com/">https://baidu.com/</a>。</br><br>如果需要添加说明，可以通过<code>[说明](url)</code>来创建外部链接，同样地，可以对链接字体进行设置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com/</span>)</span><br><span class="line"><span class="strong">**[<span class="string">加粗</span>](<span class="link">https://baidu.com/</span>)**</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">粗斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line">~~[<span class="string">删除线</span>](<span class="link">https://baidu.com/</span>)~~.</span><br><span class="line">[<span class="string">`行内代码`</span>](<span class="link">https://baidu.com/</span>).</span><br></pre></td></tr></table></figure><p>效果：<br><a href="https://baidu.com/">百度</a><br><strong><a href="https://baidu.com/">加粗</a></strong>.<br><em><a href="https://baidu.com/">斜体</a></em>.<br><em><a href="https://baidu.com/">粗斜体</a></em>.<br><del><a href="https://baidu.com/">删除线</a></del>.<br><a href="https://baidu.com/"><code>行内代码</code></a>.</p><h2 id="参考链接引用"><a href="#参考链接引用" class="headerlink" title="参考链接引用"></a>参考链接引用</h2><p>例如文章可能需要多次引用同一个链接，可以通过这种方式实现复用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"><span class="selector-tag">B</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[百度]</span>: https://baidu.com/ <span class="string">&quot;注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别&quot;</span></span><br></pre></td></tr></table></figure><p>效果：<br>A处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a><br>B处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>通过<code>![说明](图片地址)</code>来创建图片。其中图片地址支持url和本地图片路径。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[可能不存在的网络照片.jpeg]</span>(https://cdn.imalan.cn/img/post/<span class="number">2934349</span>b033b5bb5a19efc7233d3d539b700bcf5.jpg)</span><br><span class="line">!<span class="selector-attr">[rpc调用]</span>(../images/详解RPC协议/rpc调用流程.jpeg)</span><br></pre></td></tr></table></figure><p>效果：<br><img src="https://cdn.imalan.cn/img/post/2934349b033b5bb5a19efc7233d3d539b700bcf5.jpg" alt="可能不存在的网络照片.jpeg"></p><p><img src="/../images/%E8%AF%A6%E8%A7%A3RPC/rpc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpeg" alt="rpc调用"></p><blockquote><p>不同的 Markdown 应用程序在处理 URL 的方式可能存在不同，<strong>因此推荐使用编码后的url</strong>。例如如果添加的链接中有空格，为了兼容起见，最好使用 %20 （空格的编码形式）来代替空格。</p></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>通过<code>|</code>来设置表格，通过<code>---</code>来设置表头。其中，表头可以通过<code>:--:</code>来设置居中，<code>:--</code>来设置居左，<code>---:</code>来设置居右。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 姓名 | 年龄 | 性别 |</span><br><span class="line">| :--- | ---: | :--: |</span><br><span class="line">| 张三 | 18 | 男 |</span><br></pre></td></tr></table></figure><p>效果：</br></p><table><thead><tr><th align="left">姓名</th><th align="right">年龄</th><th align="center">性别</th></tr></thead><tbody><tr><td align="left">张三</td><td align="right">18</td><td align="center">男</td></tr></tbody></table><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>通过连续3个以上的相同符号：<code>*</code>、<code>-</code>、<code>_</code>来创建分割线。分割线的效果同样取决于使用的解析器。在实践中，最好在分隔线的前后均添加空白行。</br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">分割线1</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">分割线2</span></span><br><span class="line"><span class="string">___</span></span><br><span class="line"><span class="string">分割线3</span></span><br></pre></td></tr></table></figure><p>效果：</p><hr><p>分割线1</p><hr><p>分割线2</p><hr><p>分割线3</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
