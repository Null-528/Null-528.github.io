<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown语法</title>
      <link href="/post/3c50d03d.html"/>
      <url>/post/3c50d03d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>Markdown 由 John Gruber 和 Aaron Swartz 于 2004 年创建，目标是创造一种web文本格式，尽可能方便人们阅读和写作。但起初它的设计主要针对一些简单日常的使用场景，并支持用户通过内联html来支持未涵盖到的语法，见<a href="https://daringfireball.net/projects/markdown/syntax">Markdown基本语法</a>。后来一些个人和组织开始通过添加其他元素来扩展基本语法，很多的Markdown处理器使用的都是拓展后的语言，例如Typora 使用的是<a href="https://github.github.com/gfm/">GitHub Flavored Markdown(GFM)</a>。</p><blockquote><p>John Gruber（1973-？） 是一个美国宾夕法尼亚州的技术博主，也是苹果公司的狂热粉丝，后来通过全职运行他的独立博客<a href="https://daringfireball.net/">Daring Fireball</a>，和有声杂志The talk show，分享他的技术见解和苹果产品的最新消息和点评。</p></blockquote><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2. 标题"></a>2. 标题</h1><p>通过不同个数的『#』来设置标题，最多支持六级标题。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br><span class="line">####### 不支持七级标题</span><br></pre></td></tr></table></figure><p>其中，一级和二级标题还有一种写法：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">===================</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">--------------------</span></span><br></pre></td></tr></table></figure><h1 id="3-段落"><a href="#3-段落" class="headerlink" title="3. 段落"></a>3. 段落</h1><p>一般段落，通过换行来创建即可。在idea中可以通过setting-&gt;editor-&gt;general-&gt;soft wrap来设置全局自动换行。有需要强制换行的，通过在行尾添加<code>&lt;/br&gt;</code>来强制换行。</br><br>另外，段落<strong>不支持</strong>使用空格或tab来缩进。</p><h1 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a>4. 引用</h1><p>通过<code>&gt;</code>来进行块引用，支持嵌套。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">这是一层引用</span></span><br><span class="line">&gt;&gt; 这是二层引用（后面空一行表示结束第一层引用）</span><br><span class="line"><span class="meta prompt_">&gt;</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">回到第一层引用</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">### 可以添加*标题*</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">- 和其他元素</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这是一层引用</p><blockquote><p>这是二层引用</p></blockquote><p>回到第一层引用</p><h3 id="可以添加标题"><a href="#可以添加标题" class="headerlink" title="可以添加标题"></a>可以添加标题</h3><ul><li>和其他元素，但是是否渲染以及渲染效果取决于使用的解析器。</li></ul></blockquote><h1 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a>5. 列表</h1><p>无序列表通过<code>-</code>、<code>+</code>或<code>*</code>来创建，支持嵌套。有序列表通过数字加<code>.</code>来创建，支持嵌套和相互嵌套。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是无序列表</span><br><span class="line"><span class="bullet">-</span> 无序1</span><br><span class="line"><span class="bullet">    -</span> 嵌套1</span><br><span class="line"><span class="bullet">+</span> 无序2</span><br><span class="line"><span class="bullet">*</span> 无序3</span><br><span class="line">这是有序列表</span><br><span class="line"><span class="bullet">1.</span> 有序1</span><br><span class="line"><span class="bullet">   1.</span> 嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)</span><br><span class="line"><span class="bullet">      -</span> 无序和有序可以相互嵌套</span><br><span class="line"><span class="bullet">2.</span> 有序2</span><br></pre></td></tr></table></figure><p>效果：</br><br>这是无序列表</p><ul><li>无序1<ul><li>嵌套1</li></ul></li></ul><ul><li>无序2</li></ul><ul><li>无序3</li></ul><blockquote><p>一般来说，同一个列表中最好不要混用不同的分隔符，否则有些解析器可能会识别混乱造成渲染错误。</p></blockquote><p></br>这是有序列表</p><ol><li>有序1<ol><li>嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)<ul><li>无序和有序可以相互嵌套</li></ul></li></ol></li><li>有序2</li></ol><h1 id="6-代码"><a href="#6-代码" class="headerlink" title="6. 代码"></a>6. 代码</h1><p>通过反引号『&#96;』来创建行内代码，不支持嵌套。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`hello world!`</span></span><br></pre></td></tr></table></figure><p>效果：<code>hello world!</code><br/><br>一般情况下我们都使用反斜杠<code>\</code>进行转义，但特别地，如果要对反引号进行转义，需要通过双反引号。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">``Use `code` in your Markdown file.``</span><br><span class="line">`` `hello world!` ``</span><br></pre></td></tr></table></figure><p>效果：<code>Use `code` in your Markdown file.</code> <code>`hello world!`</code> </p><p>通过前后2个『&#96;&#96;&#96;』来创建封闭的代码块，在起始的三个”&#96;”后可以表明使用的语言（小写），来进行语法高亮。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHello</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法高亮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-字体"><a href="#7-字体" class="headerlink" title="7. 字体"></a>7. 字体</h1><p>使用<code>*</code>或<code>_</code>来设置斜体，使用<code>**</code>或<code>__</code>来设置加粗，使用<code>***</code>或<code>___</code>来设置斜体加粗，使用<code>~~</code>来设置删除线。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*斜体*</span></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="emphasis">__加粗__</span></span><br><span class="line"><span class="strong">***斜体加粗**</span>*</span><br><span class="line"><span class="emphasis">___斜体加粗__</span>_</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：<br><em>斜体</em><br><em>斜体</em><br><strong>加粗</strong><br><strong>加粗</strong><br><em><strong>斜体加粗</strong></em><br><em><strong>斜体加粗</strong></em><br><del>删除线</del></p><h1 id="8-超链接"><a href="#8-超链接" class="headerlink" title="8. 超链接"></a>8. 超链接</h1><h2 id="8-1-外部url直接引用"><a href="#8-1-外部url直接引用" class="headerlink" title="8.1 外部url直接引用"></a>8.1 外部url直接引用</h2><p>通过&lt;&gt;可以直接创建外部引用链接。如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:<span class="comment">//baidu.com/&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<a href="https://baidu.com/">https://baidu.com/</a>。</br><br>如果需要添加说明，可以通过<code>[说明](url)</code>来创建外部链接，同样地，可以对链接字体进行设置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com/</span>)</span><br><span class="line"><span class="strong">**[<span class="string">加粗</span>](<span class="link">https://baidu.com/</span>)**</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">粗斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line">~~[<span class="string">删除线</span>](<span class="link">https://baidu.com/</span>)~~.</span><br><span class="line">[<span class="string">`行内代码`</span>](<span class="link">https://baidu.com/</span>).</span><br></pre></td></tr></table></figure><p>效果：<br><a href="https://baidu.com/">百度</a><br><strong><a href="https://baidu.com/">加粗</a></strong>.<br><em><a href="https://baidu.com/">斜体</a></em>.<br><em><a href="https://baidu.com/">粗斜体</a></em>.<br><del><a href="https://baidu.com/">删除线</a></del>.<br><a href="https://baidu.com/"><code>行内代码</code></a>.</p><h2 id="8-2-参考链接引用"><a href="#8-2-参考链接引用" class="headerlink" title="8.2 参考链接引用"></a>8.2 参考链接引用</h2><p>例如文章可能需要多次引用同一个链接，可以通过这种方式实现复用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"><span class="selector-tag">B</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[百度]</span>: https://baidu.com/ <span class="string">&quot;注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别&quot;</span></span><br></pre></td></tr></table></figure><p>效果：<br>A处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a><br>B处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a></p><h2 id="8-3-图片"><a href="#8-3-图片" class="headerlink" title="8.3 图片"></a>8.3 图片</h2><p>通过<code>![说明](图片地址)</code>来创建图片。其中图片地址支持url和本地图片路径。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[可能不存在的网络照片.jpeg]</span>(<span class="attribute">https</span>:<span class="comment">//cdn.imalan.cn/img/post/2934349b033b5bb5a19efc7233d3d539b700bcf5.jpg)</span></span><br></pre></td></tr></table></figure><p>效果：<br><img src="https://cdn.imalan.cn/img/post/2934349b033b5bb5a19efc7233d3d539b700bcf5.jpg" alt="可能不存在的网络照片.jpeg"></p><blockquote><p>不同的 Markdown 应用程序在处理 URL 的方式可能存在不同，<strong>因此推荐使用编码后的url</strong>。例如如果添加的链接中有空格，为了兼容起见，最好使用 %20 （空格的编码形式）来代替空格。</p></blockquote><h1 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h1><p>通过<code>|</code>来设置表格，通过<code>---</code>来设置表头。其中，表头可以通过<code>:--:</code>来设置居中，<code>:--</code>来设置居左，<code>---:</code>来设置居右。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 姓名 | 年龄 | 性别 |</span><br><span class="line">| :--- | ---: | :--: |</span><br><span class="line">| 张三 | 18 | 男 |</span><br></pre></td></tr></table></figure><p>效果：</br></p><table><thead><tr><th align="left">姓名</th><th align="right">年龄</th><th align="center">性别</th></tr></thead><tbody><tr><td align="left">张三</td><td align="right">18</td><td align="center">男</td></tr></tbody></table><h1 id="10-分割线"><a href="#10-分割线" class="headerlink" title="10. 分割线"></a>10. 分割线</h1><p>通过连续3个以上的相同符号：<code>*</code>、<code>-</code>、<code>_</code>来创建分割线。分割线的效果同样取决于使用的解析器。在实践中，最好在分隔线的前后均添加空白行。</br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">分割线1</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">分割线2</span></span><br><span class="line"><span class="string">___</span></span><br><span class="line"><span class="string">分割线3</span></span><br></pre></td></tr></table></figure><p>效果：</p><hr><p>分割线1</p><hr><p>分割线2</p><hr><p>分割线3</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Grpg协议</title>
      <link href="/post/12cc1a39.html"/>
      <url>/post/12cc1a39.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是Grpg协议"><a href="#1-什么是Grpg协议" class="headerlink" title="1. 什么是Grpg协议"></a>1. 什么是Grpg协议</h1><pre><code>Grpc[https://grpc.io/]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础系列】代理</title>
      <link href="/post/53c8b77c.html"/>
      <url>/post/53c8b77c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是代理"><a href="#1-什么是代理" class="headerlink" title="1.什么是代理"></a>1.什么是代理</h1><p>   在编译时期无法确定需要实现哪个接口时，我们可以使用代理，在运行时创建实现一组给定接口的新类。对于编写应用程序的程序员来说这种场景比较少见，但对某些系统应用程序，代理带来的灵活性十分重要。</p><p>   总体来说，代理就是为某些对象的某种行为提供一个代理对象，并由代理对象完全控制该行为的实际执行。代理分为静态代理和动态代理两类，两者的主要区别就是代理类生成的时机，其中：</p><ul><li>静态代理：在程序运行前，创建代理类，实现代理逻辑，编译时就已经实现了，编译完成后代理类成为一个实际的class文件。</br></li><li>动态代理：在程序运行时，运用反射机制动态创建代理类，编译时没有实际的class文件，而是在运行时动态生成字节码。</br></li></ul><p>特别地，动态代理又有两种主要的实现方式，分别为：JDK 动态代理和 CGLIB 动态代理。</p><h1 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h1><p>   当我们需要在不修改目标对象的前提下，扩展目标对象的功能，就可以使用静态代理。例如：</p><p>我们有一个接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个目标对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDao</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们的静态代理对象可以这么构建，可以看出，静态Proxy相当于将要代理的对象封装了一层，重写并嵌套使用其所有的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IHello target；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(IHello target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">        target.sayHello();</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h1><p>   假如我们要构造一个类的对象，这个类实现了1个或多个接口，但在编译时期，可能并不知道这些接口是什么，这个时候就可以使用动态代理来解决我们的问题。动态代理有两大类：JDK和CGLIB，两者最大的不同是JDK需要代理的对象是基于接口实现的，而CGLIB作为第三方代码生成的类库，没有这种需求。</p><p>   动态代理基本会代理所有的代理对象的方法,对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发，例如getClass()、clone()方法。 </p><h2 id="3-1-JDK动态代理"><a href="#3-1-JDK动态代理" class="headerlink" title="3.1 JDK动态代理"></a>3.1 JDK动态代理</h2><p>   JDK 动态代理就是基于 JDK 实现的代理模式，主要运用了其拦截器和反射机制，其代理对象是由 JDK 动态生成的，而不像静态代理方式写死代理对象和被代理类。JDK 代理是不需要第三方库支持的，只需要 JDK 环境就可以进行代理，使用条件：</p><ul><li>必须实现InvocationHandler</li><li>使用Proxy.newProxyInstance产生代理对象</li><li>被代理的对象必须实现一个或多个接口</li></ul><blockquote><p>使用 JDK 动态代理的五大步骤：</br><br>1.通过实现InvocationHandler接口来定义自己的InvocationHandler</br><br>2.通过Proxy.getProxyClass获得动态代理类</br><br>3.通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)</br><br>4.通过构造函数获得代理对象并将自定义的InvocationHandler实例对象为参数传入</br><br>5.通过代理对象调用目标方法。</br></p></blockquote><p>  接下来，我们就按上面的 5 个步骤，写一个 JDK 动态代理的示例。</p><ul><li>PersonProxyFactory，HelloImpl的代理类，这个代理类中需要实现InvocationHandler接口的invoke方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IHello <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> invocationHandler();</span><br><span class="line">        <span class="comment">// 传入代理目标使用的类加载器、代理目标实现的接口类型、对应的事件处理器。</span></span><br><span class="line">        <span class="keyword">return</span> (IHello) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InvocationHandler <span class="title function_">invocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现InvocationHandler接口的invoke方法</span></span><br><span class="line">        <span class="keyword">return</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(instance, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>MyProxyTest，测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PersonProxyFactory</span> <span class="variable">personProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxyFactory</span>(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">        personProxyFactory.createProxy().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-CGLIB动态代理"><a href="#3-2-CGLIB动态代理" class="headerlink" title="3.2 CGLIB动态代理"></a>3.2 CGLIB动态代理</h2><p>cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。它广泛地被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</p><p>还是之前的几个例子，我们实现CGLIB的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibPersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CGLibPersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB HELLO WORLD !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h2><ul><li>在动态代理的过程中，如果被代理的对象的执行方法抛错，调用方会得到InvocationTargetException类的异常，这个异常封装了实际的问题，需要使用getTargetException()方法将内容取出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
