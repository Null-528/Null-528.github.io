<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>详解gRPC协议</title>
      <link href="/post/12cc1a39.html"/>
      <url>/post/12cc1a39.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是gRPC协议"><a href="#1-什么是gRPC协议" class="headerlink" title="1. 什么是gRPC协议"></a>1. 什么是gRPC协议</h1><p><a href="https://grpc.io/">gRPC</a> 是一个由Google开发的高性能开源的RPC框架，基于HTTP&#x2F;2协议标准设计，支持GO，C++，JAVA，Python等多种语言。我们之前已经介绍过了RPC框架，见<a href="https://null-528.github.io/post/b9eb0f9.html">详解RPC</a>，gRPC整体流程和RPC是完全一致的：</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/grpc%E8%B0%83%E7%94%A8.svg" alt="grpc调用"></p><h2 id="1-1-协议缓冲区Protocol-Buffers"><a href="#1-1-协议缓冲区Protocol-Buffers" class="headerlink" title="1.1 协议缓冲区Protocol Buffers"></a>1.1 协议缓冲区Protocol Buffers</h2><p>gRPC作为其一种实现默认使用谷歌自家开源的Protocol Buffers来序列化和反序列化结构化数据。它与 JSON 类似，只是体积更小、速度更快，而且能生成本地语言绑定。</p><p>例如我们有一个扩展名为 text.proto 的普通文本文件。协议缓冲区数据的结构为message，其中每条消息都是一条小的逻辑信息记录，包含一系列称为字段的名-值对:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="type">bool</span> has_ponycopter = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在.proto文件确定了数据结构，我们就可以使用协议缓冲区编辑器protoc从proto的定义中生成相关语言的代码。例如Java，就会生成一个Person.java类，其中包含一个Person对象，该对象具有name、id和has_ponycopter字段，并且有类似lombok的@Data，有各个字段的getter和setter、整个类的toString方法等。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解RPC</title>
      <link href="/post/b9eb0f9.html"/>
      <url>/post/b9eb0f9.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是RPC"><a href="#1-什么是RPC" class="headerlink" title="1. 什么是RPC"></a>1. 什么是RPC</h1><p>在最早的时候，进程只能获取自己栈帧内的数据，例如有2个进程，两者是无法数据通信的。为了解决这个问题，出现了本地进程间通信IPC（Inter-Process Communication）技术，通过如共享内存，管道等手段，来交换数据。但后来业务逐渐复杂，磁盘、CPU等资源逐渐达到瓶颈，人们开始考虑将多台计算机组成一个集群来提高服务的吞吐能力，这就是分布式。</p><p>RPC（Remote Procedure Call），即远程程序调用，可以理解为RPC是将进程间通信的范围从单机扩大到了一个共享网络中，这样不同服务间调用方法像同一服务间调用本地方法一样，而不需要调用者了解底层网络技术的协议。如cassandra集群节点接通信，以及SpringCloud 微服务中各个服务之间的通信。</p><p>RPC 现在所指的概念也有些模糊，一般来说我们将其理解为一种request-response的网络传输思想，但在wiki等一些网站上，rpc也可以狭义地理解为一种协议，并且需要通过stub等动态代理来实现消息传输。</p><h1 id="2-RPC协议模型"><a href="#2-RPC协议模型" class="headerlink" title="2. RPC协议模型"></a>2. RPC协议模型</h1><p>这里介绍在wiki等网站<strong>狭义</strong>定义的RPC协议模型：<br><img src="/../images/%E8%AF%A6%E8%A7%A3RPC/rpc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpeg" alt="rpc调用"><br>整个过程可以分为以下几个阶段：</p><ol><li>客户机调用本地的Stub，将参数传递进去。</li><li>Stub将参数marshall（打包）到消息中。这个过程包括将参数标准化的过程。</li><li>Stub将消息传递给传输层，再由传输层发送到远程服务器机器。</li><li>服务器的Stub收到消息后，存根对参数进行unmarshall（解包），然后根据参数调用本地服务。</li><li>服务器服务完成调用后，将结果参数返回给服务器Stub，服务器Stub再将结果参数标准化并marshall（打包）到消息中。</li><li>服务器Stub将消息传递给传输层，传输层再发送给客户端Stub。</li><li>客户端Stub解析参数，将结果返回给调用者。</li></ol><p>在上面的流程中，看上去两个进程是1对1同步阻塞的，但实际上rpc并没有限制异步调用，可以选择异步来提高并发。</p><blockquote><p>这里用Stub存根来指代远程服务的本地代理程序或者软件，它是客户端和应用程序的中间层，用于处理一些调用细节如负责封装请求、解析响应、处理网络通信等。例如在java中，Stab就是通过动态代理技术实现的。</p><p>Stub一般都是RPC框架自动生成的，开发者不需要关心。</p></blockquote><h1 id="3-RPC系统"><a href="#3-RPC系统" class="headerlink" title="3. RPC系统"></a>3. RPC系统</h1><p>为了让不同的客户端访问服务器，人们创建了许多标准化的 RPC 框架。这些框架大多使用接口描述语言IDL(Interface description language)来让各种平台调用 RPC。IDL 文件随后可用于生成客户端与服务器之间的接口代码。目前有以下这些常见的 RPC 框架：</p><ol><li><p>gRPC：由Google开发的高性能、跨语言的RPC框架，基于HTTP&#x2F;2协议，支持多种语言，如C++, Java, Python, Go等。gRPC使用Protocol Buffers作为默认的序列化协议，支持双向流、流式处理等特性。</p></li><li><p>Apache Thrift：由Facebook开发的跨语言的RPC框架，支持多种语言，如C++, Java, Python, PHP等。Thrift使用自定义的IDL（Interface Definition Language）来定义服务接口，支持多种传输协议和序列化协议。如cassandra执行cql时使用的就是Thrift。</p></li><li><p>Apache Dubbo：由阿里巴巴开发的高性能、轻量级的RPC框架，支持多种语言，如Java, Go, Python等。Dubbo提供了丰富的功能，如负载均衡、服务注册与发现、服务治理等。但官网的性能测试数据可能并不准确，实际使用中性能表现不如gRPC，可以参考<a href="https://coolshell.cn/articles/17381.html">性能测试应该怎么做？</a></p></li></ol><h1 id="4-其他常见概念"><a href="#4-其他常见概念" class="headerlink" title="4. 其他常见概念"></a>4. 其他常见概念</h1><h2 id="4-1-Restful-RPC"><a href="#4-1-Restful-RPC" class="headerlink" title="4.1 Restful &amp; RPC"></a>4.1 Restful &amp; RPC</h2><p>两者不是可以放在一起比较的概念。<br>Restful，即 Representational State Transfer(表现层状态转移)，是一种设计风格，它面向资源，对接口做出了一系列要求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取所有用户： GET /users</span><br><span class="line">获取指定用户： GET /users/&#123;<span class="built_in">id</span>&#125;</span><br><span class="line">创建用户：    POST /users</span><br><span class="line">更新用户：    PUT /users/&#123;<span class="built_in">id</span>&#125;</span><br><span class="line">删除用户：    DELETE /users/&#123;<span class="built_in">id</span>&#125;</span><br></pre></td></tr></table></figure><p>从宏观来讲，RPC是一种网络通信思想，而Restful是一种API规范。RPC本身并不限制实现框架的传输协议，只要是基于传输层之上的就可以。但Restful一定都是作用于HTTP&#x2F;HTTPS协议之上的。</p><h2 id="4-2-MQTT-RPC"><a href="#4-2-MQTT-RPC" class="headerlink" title="4.2 MQTT &amp; RPC"></a>4.2 MQTT &amp; RPC</h2><p>从定义来讲，MQTT的发布订阅模式并不完全符合RPC『远程程序调用』的定义，即MQTT的接收方不会返回调用运行计算结果。笔者认为这应该是两种网络通信方式。<br>另外，从定义来讲，RPC要求调用方和被调用方必须同时存在，而MQTT是发布订阅模式，即消息的发送者不需要知道消息接收者的存在。PC是一对一，MQTT是多对一。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Java基础系列】代理</title>
      <link href="/post/53c8b77c.html"/>
      <url>/post/53c8b77c.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是代理"><a href="#1-什么是代理" class="headerlink" title="1.什么是代理"></a>1.什么是代理</h1><p>   在编译时期无法确定需要实现哪个接口时，我们可以使用代理，在运行时创建实现一组给定接口的新类。对于编写应用程序的程序员来说这种场景比较少见，但对某些系统应用程序，代理带来的灵活性十分重要。</p><p>   总体来说，代理就是为某些对象的某种行为提供一个代理对象，并由代理对象完全控制该行为的实际执行。代理分为静态代理和动态代理两类，两者的主要区别就是代理类生成的时机，其中：</p><ul><li>静态代理：在程序运行前，创建代理类，实现代理逻辑，编译时就已经实现了，编译完成后代理类成为一个实际的class文件。</br></li><li>动态代理：在程序运行时，运用反射机制动态创建代理类，编译时没有实际的class文件，而是在运行时动态生成字节码。</br></li></ul><p>特别地，动态代理又有两种主要的实现方式，分别为：JDK 动态代理和 CGLIB 动态代理。</p><h1 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h1><p>   当我们需要在不修改目标对象的前提下，扩展目标对象的功能，就可以使用静态代理。例如：</p><p>我们有一个接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个目标对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDao</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们的静态代理对象可以这么构建，可以看出，静态Proxy相当于将要代理的对象封装了一层，重写并嵌套使用其所有的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IHello target；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(IHello target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">        target.sayHello();</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h1><p>   假如我们要构造一个类的对象，这个类实现了1个或多个接口，但在编译时期，可能并不知道这些接口是什么，这个时候就可以使用动态代理来解决我们的问题。动态代理有两大类：JDK和CGLIB，两者最大的不同是JDK需要代理的对象是基于接口实现的，而CGLIB作为第三方代码生成的类库，没有这种需求。</p><p>   动态代理基本会代理所有的代理对象的方法,对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发，例如getClass()、clone()方法。 </p><h2 id="3-1-JDK动态代理"><a href="#3-1-JDK动态代理" class="headerlink" title="3.1 JDK动态代理"></a>3.1 JDK动态代理</h2><p>   JDK 动态代理就是基于 JDK 实现的代理模式，主要运用了其拦截器和反射机制，其代理对象是由 JDK 动态生成的，而不像静态代理方式写死代理对象和被代理类。JDK 代理是不需要第三方库支持的，只需要 JDK 环境就可以进行代理，使用条件：</p><ul><li>必须实现InvocationHandler</li><li>使用Proxy.newProxyInstance产生代理对象</li><li>被代理的对象必须实现一个或多个接口</li></ul><blockquote><p>使用 JDK 动态代理的五大步骤：</br><br>1.通过实现InvocationHandler接口来定义自己的InvocationHandler</br><br>2.通过Proxy.getProxyClass获得动态代理类</br><br>3.通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)</br><br>4.通过构造函数获得代理对象并将自定义的InvocationHandler实例对象为参数传入</br><br>5.通过代理对象调用目标方法。</br></p></blockquote><p>  接下来，我们就按上面的 5 个步骤，写一个 JDK 动态代理的示例。</p><ul><li>PersonProxyFactory，HelloImpl的代理类，这个代理类中需要实现InvocationHandler接口的invoke方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IHello <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> invocationHandler();</span><br><span class="line">        <span class="comment">// 传入代理目标使用的类加载器、代理目标实现的接口类型、对应的事件处理器。</span></span><br><span class="line">        <span class="keyword">return</span> (IHello) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InvocationHandler <span class="title function_">invocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现InvocationHandler接口的invoke方法</span></span><br><span class="line">        <span class="keyword">return</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(instance, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>MyProxyTest，测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PersonProxyFactory</span> <span class="variable">personProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxyFactory</span>(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">        personProxyFactory.createProxy().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-CGLIB动态代理"><a href="#3-2-CGLIB动态代理" class="headerlink" title="3.2 CGLIB动态代理"></a>3.2 CGLIB动态代理</h2><p>cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。它广泛地被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</p><p>还是之前的几个例子，我们实现CGLIB的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibPersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CGLibPersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB HELLO WORLD !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h2><ul><li>在动态代理的过程中，如果被代理的对象的执行方法抛错，调用方会得到InvocationTargetException类的异常，这个异常封装了实际的问题，需要使用getTargetException()方法将内容取出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/post/3c50d03d.html"/>
      <url>/post/3c50d03d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>Markdown 由 John Gruber 和 Aaron Swartz 于 2004 年创建，目标是创造一种web文本格式，尽可能方便人们阅读和写作。但起初它的设计主要针对一些简单日常的使用场景，并支持用户通过内联html来支持未涵盖到的语法，见<a href="https://daringfireball.net/projects/markdown/syntax">Markdown基本语法</a>。后来一些个人和组织开始通过添加其他元素来扩展基本语法，很多的Markdown处理器使用的都是拓展后的语言，例如Typora 使用的是<a href="https://github.github.com/gfm/">GitHub Flavored Markdown(GFM)</a>。</p><blockquote><p>John Gruber（1973-？） 是一个美国宾夕法尼亚州的技术博主，也是苹果公司的狂热粉丝，后来通过全职运行他的独立博客<a href="https://daringfireball.net/">Daring Fireball</a>，和有声杂志The talk show，分享他的技术见解和苹果产品的最新消息和点评。</p></blockquote><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2. 标题"></a>2. 标题</h1><p>通过不同个数的『#』来设置标题，最多支持六级标题。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br><span class="line">####### 不支持七级标题</span><br></pre></td></tr></table></figure><p>其中，一级和二级标题还有一种写法：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">===================</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">--------------------</span></span><br></pre></td></tr></table></figure><h1 id="3-段落"><a href="#3-段落" class="headerlink" title="3. 段落"></a>3. 段落</h1><p>一般段落，通过换行来创建即可。在idea中可以通过setting-&gt;editor-&gt;general-&gt;soft wrap来设置全局自动换行。有需要强制换行的，通过在行尾添加<code>&lt;/br&gt;</code>来强制换行。</br><br>另外，段落<strong>不支持</strong>使用空格或tab来缩进。</p><h1 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a>4. 引用</h1><p>通过<code>&gt;</code>来进行块引用，支持嵌套。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">这是一层引用</span></span><br><span class="line">&gt;&gt; 这是二层引用（后面空一行表示结束第一层引用）</span><br><span class="line"><span class="meta prompt_">&gt;</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">回到第一层引用</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">### 可以添加*标题*</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">- 和其他元素</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这是一层引用</p><blockquote><p>这是二层引用</p></blockquote><p>回到第一层引用</p><h3 id="可以添加标题"><a href="#可以添加标题" class="headerlink" title="可以添加标题"></a>可以添加标题</h3><ul><li>和其他元素，但是是否渲染以及渲染效果取决于使用的解析器。</li></ul></blockquote><h1 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a>5. 列表</h1><p>无序列表通过<code>-</code>、<code>+</code>或<code>*</code>来创建，支持嵌套。有序列表通过数字加<code>.</code>来创建，支持嵌套和相互嵌套。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是无序列表</span><br><span class="line"><span class="bullet">-</span> 无序1</span><br><span class="line"><span class="bullet">    -</span> 嵌套1</span><br><span class="line"><span class="bullet">+</span> 无序2</span><br><span class="line"><span class="bullet">*</span> 无序3</span><br><span class="line">这是有序列表</span><br><span class="line"><span class="bullet">1.</span> 有序1</span><br><span class="line"><span class="bullet">   1.</span> 嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)</span><br><span class="line"><span class="bullet">      -</span> 无序和有序可以相互嵌套</span><br><span class="line"><span class="bullet">2.</span> 有序2</span><br></pre></td></tr></table></figure><p>效果：</br><br>这是无序列表</p><ul><li>无序1<ul><li>嵌套1</li></ul></li></ul><ul><li>无序2</li></ul><ul><li>无序3</li></ul><blockquote><p>一般来说，同一个列表中最好不要混用不同的分隔符，否则有些解析器可能会识别混乱造成渲染错误。</p></blockquote><p></br>这是有序列表</p><ol><li>有序1<ol><li>嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)<ul><li>无序和有序可以相互嵌套</li></ul></li></ol></li><li>有序2</li></ol><h1 id="6-代码"><a href="#6-代码" class="headerlink" title="6. 代码"></a>6. 代码</h1><p>通过反引号『&#96;』来创建行内代码，不支持嵌套。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`hello world!`</span></span><br></pre></td></tr></table></figure><p>效果：<code>hello world!</code><br/><br>一般情况下我们都使用反斜杠<code>\</code>进行转义，但特别地，如果要对反引号进行转义，需要通过双反引号。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">``Use `code` in your Markdown file.``</span><br><span class="line">`` `hello world!` ``</span><br></pre></td></tr></table></figure><p>效果：<code>Use `code` in your Markdown file.</code> <code>`hello world!`</code> </p><p>通过前后2个『&#96;&#96;&#96;』来创建封闭的代码块，在起始的三个”&#96;”后可以表明使用的语言（小写），来进行语法高亮。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHello</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法高亮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-字体"><a href="#7-字体" class="headerlink" title="7. 字体"></a>7. 字体</h1><p>使用<code>*</code>或<code>_</code>来设置斜体，使用<code>**</code>或<code>__</code>来设置加粗，使用<code>***</code>或<code>___</code>来设置斜体加粗，使用<code>~~</code>来设置删除线。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*斜体*</span></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="emphasis">__加粗__</span></span><br><span class="line"><span class="strong">***斜体加粗**</span>*</span><br><span class="line"><span class="emphasis">___斜体加粗__</span>_</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：<br><em>斜体</em><br><em>斜体</em><br><strong>加粗</strong><br><strong>加粗</strong><br><em><strong>斜体加粗</strong></em><br><em><strong>斜体加粗</strong></em><br><del>删除线</del></p><h1 id="8-超链接"><a href="#8-超链接" class="headerlink" title="8. 超链接"></a>8. 超链接</h1><h2 id="8-1-外部url直接引用"><a href="#8-1-外部url直接引用" class="headerlink" title="8.1 外部url直接引用"></a>8.1 外部url直接引用</h2><p>通过&lt;&gt;可以直接创建外部引用链接。如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:<span class="comment">//baidu.com/&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<a href="https://baidu.com/">https://baidu.com/</a>。</br><br>如果需要添加说明，可以通过<code>[说明](url)</code>来创建外部链接，同样地，可以对链接字体进行设置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com/</span>)</span><br><span class="line"><span class="strong">**[<span class="string">加粗</span>](<span class="link">https://baidu.com/</span>)**</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">粗斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line">~~[<span class="string">删除线</span>](<span class="link">https://baidu.com/</span>)~~.</span><br><span class="line">[<span class="string">`行内代码`</span>](<span class="link">https://baidu.com/</span>).</span><br></pre></td></tr></table></figure><p>效果：<br><a href="https://baidu.com/">百度</a><br><strong><a href="https://baidu.com/">加粗</a></strong>.<br><em><a href="https://baidu.com/">斜体</a></em>.<br><em><a href="https://baidu.com/">粗斜体</a></em>.<br><del><a href="https://baidu.com/">删除线</a></del>.<br><a href="https://baidu.com/"><code>行内代码</code></a>.</p><h2 id="8-2-参考链接引用"><a href="#8-2-参考链接引用" class="headerlink" title="8.2 参考链接引用"></a>8.2 参考链接引用</h2><p>例如文章可能需要多次引用同一个链接，可以通过这种方式实现复用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"><span class="selector-tag">B</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[百度]</span>: https://baidu.com/ <span class="string">&quot;注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别&quot;</span></span><br></pre></td></tr></table></figure><p>效果：<br>A处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a><br>B处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a></p><h2 id="8-3-图片"><a href="#8-3-图片" class="headerlink" title="8.3 图片"></a>8.3 图片</h2><p>通过<code>![说明](图片地址)</code>来创建图片。其中图片地址支持url和本地图片路径。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[可能不存在的网络照片.jpeg]</span>(https://cdn.imalan.cn/img/post/<span class="number">2934349</span>b033b5bb5a19efc7233d3d539b700bcf5.jpg)</span><br><span class="line">!<span class="selector-attr">[rpc调用]</span>(../images/详解RPC协议/rpc调用流程.jpeg)</span><br></pre></td></tr></table></figure><p>效果：<br><img src="https://cdn.imalan.cn/img/post/2934349b033b5bb5a19efc7233d3d539b700bcf5.jpg" alt="可能不存在的网络照片.jpeg"></p><p><img src="/../images/%E8%AF%A6%E8%A7%A3RPC/rpc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpeg" alt="rpc调用"></p><blockquote><p>不同的 Markdown 应用程序在处理 URL 的方式可能存在不同，<strong>因此推荐使用编码后的url</strong>。例如如果添加的链接中有空格，为了兼容起见，最好使用 %20 （空格的编码形式）来代替空格。</p></blockquote><h1 id="9-表格"><a href="#9-表格" class="headerlink" title="9. 表格"></a>9. 表格</h1><p>通过<code>|</code>来设置表格，通过<code>---</code>来设置表头。其中，表头可以通过<code>:--:</code>来设置居中，<code>:--</code>来设置居左，<code>---:</code>来设置居右。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 姓名 | 年龄 | 性别 |</span><br><span class="line">| :--- | ---: | :--: |</span><br><span class="line">| 张三 | 18 | 男 |</span><br></pre></td></tr></table></figure><p>效果：</br></p><table><thead><tr><th align="left">姓名</th><th align="right">年龄</th><th align="center">性别</th></tr></thead><tbody><tr><td align="left">张三</td><td align="right">18</td><td align="center">男</td></tr></tbody></table><h1 id="10-分割线"><a href="#10-分割线" class="headerlink" title="10. 分割线"></a>10. 分割线</h1><p>通过连续3个以上的相同符号：<code>*</code>、<code>-</code>、<code>_</code>来创建分割线。分割线的效果同样取决于使用的解析器。在实践中，最好在分隔线的前后均添加空白行。</br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">分割线1</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">分割线2</span></span><br><span class="line"><span class="string">___</span></span><br><span class="line"><span class="string">分割线3</span></span><br></pre></td></tr></table></figure><p>效果：</p><hr><p>分割线1</p><hr><p>分割线2</p><hr><p>分割线3</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
