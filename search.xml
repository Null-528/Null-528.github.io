<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【开发工具】Gradle使用手册</title>
      <link href="/post/274a496e.html"/>
      <url>/post/274a496e.html</url>
      
        <content type="html"><![CDATA[<p>在整理老项目的过程中，部分老项目使用的是gradle，由于groovy的拓展脚本，学习成本比maven要高一些，因此记录一些常用的命令和配置方便进行回顾。</p><p>首先，一定要注意gradle使用的版本，我自己就是因为要兼容Mac M1，操作了gradle 2.0 -&gt; 5.6.4的版本升级，导致许多插件、groovy语法都出现兼容问题，花费了很多时间去处理编译和运行的问题。</p><p>首先，最好的系统学习方法，就是在官网选择使用的版本，有详细实例和语法可以参考。例如<a href="https://docs.gradle.org/5.6.4/userguide/tutorial_using_tasks.html">5.6.4版本使用说明</a>。</p><p>下面进入正题。</p><h1 id="一、Gradle安装使用"><a href="#一、Gradle安装使用" class="headerlink" title="一、Gradle安装使用"></a>一、Gradle安装使用</h1><p>目前gradle的使用主要有两种方式：</p><ol><li>在官网下载gradle安装包，解压后配置环境变量</li></ol><h1 id="二、Gradle常用命令"><a href="#二、Gradle常用命令" class="headerlink" title="二、Gradle常用命令"></a>二、Gradle常用命令</h1><h2 id="2-1-Gradle-Task"><a href="#2-1-Gradle-Task" class="headerlink" title="2.1 Gradle Task"></a>2.1 Gradle Task</h2><p>首先，Gradle最核心的概念为task，不同task解决不同类型的功能，例如编译、打包，甚至大多数plugin也是通过拓展task类型来实现功能的。</p><p>gradle会根据用户的构建脚本，以及相关task之间配置的dependency，将这些task构建为有向无环图（DAG）。也就是说，build本质上是配置一组任务，并根据它们之间的依赖关系将它们连接起来，从而创建 DAG。任务图创建完成后，Gradle 会确定哪些任务需要按顺序运行，然后开始执行。</p><h3 id="2-1-1-Gradle-Task生命周期"><a href="#2-1-1-Gradle-Task生命周期" class="headerlink" title="2.1.1 Gradle Task生命周期"></a>2.1.1 Gradle Task生命周期</h3><p>Gradle 任务的生命周期包括以下阶段：</p><ul><li>clean: 清理任务，删除build目录</li><li>check: 检查任务，用户也可以使用check.dependsOn(task)来做一些前置检查</li><li>assemble: 编译与打包，</li><li>build(depends on: check, assemble): 构建任务，包括运行运行测试、生成文档等。</li><li>buildConfiguration: assemble那些附加到已命名配置的工件。例如，buildArchives 将执行创建附加到归档配置的任何工件所需的任何任务。</li><li>uploadConfiguration: 与 buildConfiguration 的功能相同，但也会上传所有附加到给定配置的工件。</li><li>cleanTask: 清理Task产出的output</li></ul><h2 id="2-2-Gradle-初始化顺序"><a href="#2-2-Gradle-初始化顺序" class="headerlink" title="2.2 Gradle 初始化顺序"></a>2.2 Gradle 初始化顺序</h2><p>以IDEA为例。在Gradle项目初始化时，会先读取setting.gradle脚本，这个最重要的是定义了整个项目的模块，idea需要感觉这个模块来识别各个子模块。</p><h1 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h1><h2 id="3-1-task依赖后的执行顺序"><a href="#3-1-task依赖后的执行顺序" class="headerlink" title="3.1 task依赖后的执行顺序"></a>3.1 task依赖后的执行顺序</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> taskX &#123;</span><br><span class="line">    dependsOn <span class="string">&#x27;taskY&#x27;</span></span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskX1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskX2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    configure &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskX3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> taskY &#123;</span><br><span class="line">    <span class="keyword">doFirst</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskY1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskY2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    configure &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskY3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行：<code>gradle -q taskX</code></p><p>执行结果：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">taskX3</span></span><br><span class="line">taskY3</span><br><span class="line">taskY1</span><br><span class="line">taskY2</span><br><span class="line">taskX1</span><br><span class="line">taskX2</span><br></pre></td></tr></table></figure><p>也就是说，task会按照依赖关系，先执行被依赖的task，再执行自己。在单个task而言，执行顺序为configure-&gt; doFirst -&gt; doLast。<br>其中configure是个例外，即便依赖其他task，也要先初始化好自己的配置，才会加载被依赖对象的configure。很好理解，配置先行，然后才是执行阶段。</p><h2 id="3-2-动态Task"><a href="#3-2-动态Task" class="headerlink" title="3.2 动态Task"></a>3.2 动态Task</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列-rabbitMQ</title>
      <link href="/post/24a1a957.html"/>
      <url>/post/24a1a957.html</url>
      
        <content type="html"><![CDATA[<h1 id="rabbitMQ是什么"><a href="#rabbitMQ是什么" class="headerlink" title="rabbitMQ是什么"></a>rabbitMQ是什么</h1><p>(官网)[<a href="https://www.rabbitmq.com/]">https://www.rabbitmq.com/]</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列</title>
      <link href="/post/fec99276.html"/>
      <url>/post/fec99276.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、消息队列（Message-Queue"><a href="#一、消息队列（Message-Queue" class="headerlink" title="一、消息队列（Message Queue)"></a>一、消息队列（Message Queue)</h1><h2 id="1-1-什么是消息队列？"><a href="#1-1-什么是消息队列？" class="headerlink" title="1.1 什么是消息队列？"></a>1.1 什么是消息队列？</h2><p>消息队列是一种异步的服务间通信方式，这里的服务也可以理解为不同线程&#x2F;进程。这种通信方式有这样几个特征：</p><ol><li>消息队列是<strong>点到点</strong>的传输，发送方提交Message到MQ，接收方从MQ中取出Message进行消费；</li><li>消息及相关信息在被消费或删除之前一直<strong>存储</strong>在队列上；</li><li>按照一定的<strong>顺序</strong>（例如时间或重要性）进行排序。</li><li>每条消息一般仅可被一位用户消费一次。</li><li>消息队列本身是<strong>异步</strong>的，它允许接受者在发送消息很长时间后，才被消费者消费（对比RPC协议们（如HTTP）都是同步的，客户端在请求后并需等待服务端返回响应）。</li></ol><blockquote><p>可以看到由于中间的Message是由Queue存储的，并没有进行持久化，因此一般这种类型对Message大小和流量是有限制的，超出限制后，Queue可能会进行阻塞，或者丢弃消息，当然各个产品实现细节可能不尽相同。</p><p>另外，由于消费者是需要自己定时去轮询队列进行消费的，因此也能控制下游服务的压力，将消息积压在队列中，再不丢消息的情况下，整体上会表现出对上游压力的削峰，提升服务稳定性。</p></blockquote><h2 id="1-2-和其他服务通信方式的区别"><a href="#1-2-和其他服务通信方式的区别" class="headerlink" title="1.2 和其他服务通信方式的区别"></a>1.2 和其他服务通信方式的区别</h2><p>消息队列最大的功劳应该是它解耦了服务发布方和订阅方，试想这样一个场景：<br>一个商城系统，用户在支付完成后涉及到多个服务，比如：</p><ol><li>订单系统需要记录订单</li><li>积分系统需要增加积分</li><li>通知系统需要通知用户确认地址、商家确认新订单</li><li>仓库系统需要统计出库</li></ol><p>……<br>如果我们使用RPC，线性处理后面几个服务，那么：</p><ol><li>接口时间过长，影响用户体验</li><li>一旦有某个服务挂了，整个流程都会被阻塞（试想长时间的retry），并且由于上下游耦合，有可能经常因为某个小模块挂了导致整个流程失败；</li><li>如果服务挂了就将这一单置为失败，那么用户体验会变差，降低用户体验；如果要在后台重试，那么需要额外开发存储失败记录并重试逻辑，耦合的这部分存储成本并不优雅，同时大家都知道这种情况下多模块之间一旦有接口之间的变动有多痛苦……</li></ol><p>消息队列就是这种场景的一个解决方案，上游只需要将Message发送到对应MQ，下游服务消费即可。</p><h2 id="1-3-消息队列的实现"><a href="#1-3-消息队列的实现" class="headerlink" title="1.3 消息队列的实现"></a>1.3 消息队列的实现</h2><p>目前消息队列所使用的协议有很多种，例如最简洁的MQTT，以及更加丰富的AMQP。</p><p>基于不同的协议有不同的产品， 如Apache ActiveMQ、Apache RocketMQ、Alibaba RocketMq、RabbitMQ、Kafka、HTTPSQS等。</p><h1 id="二、MQTT协议"><a href="#二、MQTT协议" class="headerlink" title="二、MQTT协议"></a>二、MQTT协议</h1><p>MQTT（Message Queuing Telemetry Transport）是IBM开发的一个应用层即时通讯协议(MQTT是在TCP传输协议之上的)，据 Arlen Nipper 在 IBM Podcast 上的自述，MQTT 原名是 MQ TT，注意 MQ 与 TT之间的空格。这是九十年代早期他在参与 Conoco Phillips 公司的一个原油管道数据采集监控系统（pipeline SCADA system）时开发的一个实时数据传输协议。它的目的在于让传感器通过带宽有限的 VSAT ，与 IBM 的 MQ Integrator 通信。由于 Nipper 是遥感和数据采集监控专业出身，所以按业内惯例取了 MQ TT 这个名字。</p><p>它有这样几个特点：</p><ol><li><strong>基于发布&#x2F;订阅</strong>实现，因此可以支持一对多的消息分发机制，消息通过MQTT Broker分发到各个Subscriber；</li><li><strong>轻量级协议</strong>，数据包更小，实现简单，在计算和内存资源需求上需求也就更少，在资源受限的设备上运行会非常高效；</li><li>MQTT一般是不会存储队列；</li><li><strong>双向通信</strong>，各个Subscriber可以向topic发布消息，也可以订阅接收topic上的消息；</li></ol><h2 id="2-1-消息服务质量等级QoS（Quality-of-Service）"><a href="#2-1-消息服务质量等级QoS（Quality-of-Service）" class="headerlink" title="2.1 消息服务质量等级QoS（Quality of Service）"></a>2.1 消息服务质量等级QoS（Quality of Service）</h2><p>MQTT的设计目标就是为了资源最紧缺的设备也能够安全运行，考虑设备所在网络的不确定性，MQTT 协议提供了 3 种消息服务质量等级（Quality of Service），保证了在不同的网络环境下消息传递的可靠性：</p><ol><li><p>QoS 0：消息最多传递一次。<br>发布者发送一条消息之后，就不再关心它有没有发送到对方，也不设置任何重发机制，因此消息传递完全依赖于TCP，可靠性较差，如果TCP关闭或重置都会丢失缓冲区消息，但接收方消费的消息不会重复。<br><img src="/../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Qos0.jpg"></p></li><li><p>QoS 1：消息传递至少 1 次。<br>包含了简单的重发机制，发布者发送携带的Packet ID的消息，然后等待接收者的 ACK，如果收到携带相同Packet ID的 ACK 则从缓存中删除该消息，否则重新发送消息。<br>这种模式能保证消息至少能到达一次，但如果由于网络问题丢失了ACK，那么消息可能会被重复发送。<br><img src="/../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Qos1.jpg"></p></li><li><p>QoS 2：消息仅传送一次。<br>设计了重发和重复消息发现机制，保证消息到达对方并且严格只到达一次。但这种方法意味着要使用类似三次握手的机制反复确认消息的接收情况，传输效率相应也就会降低。<br>比如Qos1，前半段流程是类似的，区别在于在发送方收到对应ACK后，还需要额外发送一次PUBREL报文，通知接收方准备释放这个Packet ID，接收方也需要存储Packet ID，对于<br><img src="/../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Qos2.jpg"></p></li></ol><h2 id="2-2-MQTT-vs-其他协议"><a href="#2-2-MQTT-vs-其他协议" class="headerlink" title="2.2 MQTT vs 其他协议"></a>2.2 MQTT vs 其他协议</h2><h3 id="2-2-1-MQTT-vs-HTTP"><a href="#2-2-1-MQTT-vs-HTTP" class="headerlink" title="2.2.1 MQTT vs HTTP"></a>2.2.1 MQTT vs HTTP</h3><p>MQTT 的最小报文仅为 2 个字节，比 HTTP 占用更少的网络开销。<br>MQTT 与 HTTP 都能使用 TCP 连接，并实现稳定、可靠的网络连接。<br>MQTT 基于发布订阅模型，HTTP 基于请求响应，因此 MQTT 支持双工通信。<br>MQTT 可实时推送消息，但 HTTP 需要通过轮询获取数据更新。<br>MQTT 是有状态的，但是 HTTP 是无状态的。<br>MQTT 可从连接异常断开中恢复，HTTP 无法实现此目标。</p><h3 id="2-2-2-MQTT-vs-XMPP"><a href="#2-2-2-MQTT-vs-XMPP" class="headerlink" title="2.2.2 MQTT vs XMPP"></a>2.2.2 MQTT vs XMPP</h3><p>MQTT 协议设计简单轻量、路由灵活，将在移动互联网、物联网消息领域，全面取代 PC 时代的 XMPP 协议。</p><p>MQTT 报文体积小且编解码容易，XMPP 基于繁重的 XML，报文体积大且交互繁琐。<br>MQTT 基于发布订阅模式，相比 XMPP 基于 JID 的点对点消息路由更为灵活。<br>MQTT 支持 JSON、二进制等不同类型报文。XMPP 采用 XML 承载报文，二进制必须 Base64 编码等处理。<br>MQTT 通过 QoS 保证消息可靠传输，XMPP 主协议并未定义类似机制。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件、网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议、消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【方案设计】分布式心跳检测方案Phi-Accrual-FailureDetector</title>
      <link href="/post/23ac10a5.html"/>
      <url>/post/23ac10a5.html</url>
      
        <content type="html"><![CDATA[<p>最近由于架构调整刚接手的一个新产品，发现其心跳检测方案存在一些问题。产品本身原来是通过k8s开启headless，然后通过dns解析获取到所有pod的ip，然后通过请求服务的健康检测接口是否返回，来判断服务是否存活。消亡的节点会被放进黑名单中，黑名单会定时失效，失效以后可以再次通过心跳任务来检测服务是否失效。</p><p>但由于线上某个网络组件问题，导致某个节点DNS虽然能稳定解析出某个节点，但是会时不时发送消息失败，导致这个节点反复出入黑名单。线上一些大流量客户甚至可感延迟，导致客户体验很差。</p><p>想到之前对cassandra较为熟悉，因此我打算仔细调研一下cassandra使用的Phi-Accrual FailureDetector心跳方案，通过可信度来决定是否剔除节点，而不是通过单次访问的结果进行判断，当然还有其他简单的解决方案可以采用，但学习一下优秀的设计方案，还是很有必要的。</p><p>那么我们开始吧。</p><h1 id="什么是Phi-Accrual-FailureDetector"><a href="#什么是Phi-Accrual-FailureDetector" class="headerlink" title="什么是Phi-Accrual FailureDetector"></a>什么是Phi-Accrual FailureDetector</h1><p>Phi-Accrual FailureDetector是Google提出的一种心跳检测方案，cassandra的FailureDetector类注解中提到，『This FailureDetector is an implementation of the paper titled “The Phi Accrual Failure Detector” by Hayashibara.』(<a href="https://ieeexplore.ieee.org/document/1353004">原文</a>)。结合论文和源码实现，我们能更好地理解这种阈值和积累型故障检测器。</p><blockquote><p>作者是京都产业大学信息科学与工程学院的教授，主要研究都是围绕着分布式服务探测和网络协议。</p></blockquote><p>累积行故障检测器相对传统心跳检测，有1个主要区别：<br>如果只根据是否能接收到心跳来判断，那么节点状态就只有死亡和存活两种状态。但实际上两者中间由于网络波动，并不是这样一个二态关系，中间还有一种suspect状态。</p><p>因此系统可以用一个连续的『可信度』来描述节点是否有故障，这个值我们用Phi表示，并且增加一个失效阈值，从而调整故障检测器的敏感度，敏感度小表示敏感度更高，反之更低，不过两者一般不是成一个线性关系。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="累积分布函数"><a href="#累积分布函数" class="headerlink" title="累积分布函数"></a>累积分布函数</h2><p>可以看出，计算可信度的方法至关重要，他决定了阈值的选择以及一个节点是否需要被加入黑名单。</p><p>指数分布的 “累积分布函数 “有很多实现方法，原论文中建议用高斯分布来近似分布，但cassandra的开发者实验认为指数分布的效果更优秀，这也可能和cassandra使用gossip协议而不是点对点的心跳轮询有关。一般如果是点对点的心跳轮询，那么故障将遵循正态分布，但由于gossip从端点 A 到端点 B 是以随机间隔发送的，它们很可能构成一个泊松过程。</p><p>cassandra曾对计算步骤做过<a href="https://issues.apache.org/jira/browse/CASSANDRA-2597">说明</a>，我们再次梳理理解一下：</p><p>假设我们的服务发现方为A，服务注册方为B。P_later表示一个端点 B 不可用的可能性。t 表示 A 收到 B 发出最后一条 Syn&#x2F;Ack&#x2F;Ack2 gossip 报文以来所经过的时间：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">P_later</span><span class="params">(t)</span></span> = <span class="number">1</span> - <span class="built_in">F</span>(t)</span><br></pre></td></tr></table></figure><p>其中，F(t) 是事件分布的 CDF。对于指数分布，CDF 为 1 - e^(-Lt)，其中 L 是速率参数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P_later(<span class="name">t</span>) = <span class="number">1</span> - (<span class="number">1</span> - e^(<span class="name">-Lt</span>))</span><br></pre></td></tr></table></figure><p>速率参数 L 的最大似然估计值为 1&#x2F;mean，其中 mean 是实际数据中观察到的时间的算术平均值（此处为来自端点 B 的最新流言信息到达时间）。我们预计这个速率参数会随时间变化，因此有必要存储到达时间间隔的滑动窗口。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P_later(<span class="name">t</span>) = <span class="number">1</span> - (<span class="number">1</span> - e^(<span class="name">-t/mean</span>))</span><br></pre></td></tr></table></figure><p>Cassandra 的原作者到此为止。Apache Cassandra 开发人员做了明显的简化：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">P_later</span><span class="params">(t)</span></span> = e^(-t/mean)</span><br></pre></td></tr></table></figure><p>但我要进一步看看 P_later 在 phi 计算中的使用方式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">phi</span><span class="params">(t)</span></span> = <span class="built_in">-log10</span>(<span class="built_in">P_later</span>(t))</span><br></pre></td></tr></table></figure><p>展开为</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">phi</span>(<span class="built_in">t</span>) = -<span class="built_in">log10</span>(e^(-<span class="built_in">t</span>/mean))</span><br></pre></td></tr></table></figure><p>等等，指数的对数？这不是意味着…</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">phi</span>(<span class="built_in">t</span>) = -<span class="built_in">log</span>(e^(-<span class="built_in">t</span>/mean))/ <span class="built_in">log</span>(<span class="number">10</span>) = (<span class="built_in">t</span>/mean) / <span class="built_in">log</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>所以大约</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">phi</span>(<span class="built_in">t</span>) = <span class="number">0.4342945</span> * <span class="built_in">t</span>/mean</span><br></pre></td></tr></table></figure><p>是的，对于计算机来说，计算起来比</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-<span class="number">1</span>) * <span class="keyword">Math</span>.log10(<span class="keyword">Math</span>.pow(<span class="keyword">Math</span>.e, ((-<span class="number">1</span>) * (t)/mean))))</span><br></pre></td></tr></table></figure><p>的方法简单得多。</p><p>因此，在代码中，我们看到phi的计算为：<br><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88Phi-Accrual-FailureDetector/phi%E4%BB%A3%E7%A0%81.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式，方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心跳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot扩展点:EnvironmentPostProcessor</title>
      <link href="/post/cd861ef5.html"/>
      <url>/post/cd861ef5.html</url>
      
        <content type="html"><![CDATA[<p>在一些时候，例如我们在服务中需要进行集成测试时，需要将多个模块依赖的底层数据库先拉起，才能进行完整数据通路的测试。例如业务依赖的mysql、<br>一些外部存储容器如redis、minio等。</p><p>这个时候我们就可以通过SpringBoot提供的EnvironmentPostProcessor扩展点，在环境加载后，服务启动前的阶段，对环境进行扩展。</p><blockquote><p>官网文档：<a href="https://docs.spring.io/spring-boot/docs/2.5.2/reference/htmlsingle/#howto.application.customize-the-environment-or-application-context">https://docs.spring.io/spring-boot/docs/2.5.2/reference/htmlsingle/#howto.application.customize-the-environment-or-application-context</a></p></blockquote><p>该类的作用是在SpringBoot项目启动之前自定义环境变量，可以在项目启动之前从非标准springboot配置文件中读取相关的配置并填充到springboot上下文中。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解gRPC协议(二)</title>
      <link href="/post/5a25e7f5.html"/>
      <url>/post/5a25e7f5.html</url>
      
        <content type="html"><![CDATA[<p>我们在之前的文章中介绍了gRPC协议使用的protobuf，从而定义gRPC service和具体用到的对象模型。这篇文章中，我们来具体通过gRPC来调用一个服务，看看gRPC是如何工作的。</p><p>gRPC 使用 HTTP&#x2F;2 作为传输协议。 虽然与 HTTP 1.1 也能兼容，但 HTTP&#x2F;2 具有许多高级功能：</p><p>用于数据传输的二进制组帧协议 - 与 HTTP 1.1 不同，HTTP 1.1 是基于文本的。<br>对通过同一连接发送多个并行请求的多路复用支持 - HTTP 1.1 将处理限制为一次处理一个请求&#x2F;响应消息。<br>双向全双工通信，用于同时发送客户端请求和服务器响应。<br>内置流式处理，支持对大型数据集进行异步流式处理的请求和响应。<br>减少网络使用率的标头压缩。<br>gRPC 是轻量型且高性能的。 其处理速度可以比 JSON 序列化快 8 倍，消息小 60% 到 80%。 在 Microsoft Windows Communication Foundation (WCF) 中，gRPC 的性能超过经过高度优化的 NetTCP 绑定的速度和效率。 与偏向于 Microsoft 堆栈的 NetTCP 不同，gRPC 是跨平台的。</p><p>建议在以下场景中使用 gRPC：</p><p>需要立即响应才能继续处理的同步后端微服务到微服务通信。<br>需要支持混合编程平台的 Polyglot 环境。<br>性能至关重要的低延迟和高吞吐量通信。<br>点到点实时通信 - gRPC 无需轮询即可实时推送消息，并且能对双向流式处理提供出色的支持。<br>网络受约束环境 - 二进制 gRPC 消息始终小于等效的基于文本的 JSON 消息。<br>在撰写本文时，gRPC 主要用于后端服务。 新式浏览器无法提供支持前端 gRPC 客户端所需的 HTTP&#x2F;2 控制级别。 也就是说，支持使用 .NET 的 gRPC-Web，能够从使用 JavaScript 或 Blazor WebAssembly 技术构建的基于浏览器的应用进行 gRPC 通信。 gRPC-Web 使 ASP.NET Core gRPC 应用能支持浏览器应用中的 gRPC 功能：</p><p>强类型、代码生成的客户端<br>压缩 Protobuf 消息<br>服务器流式处理</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解gRPC协议(一)Protobuf</title>
      <link href="/post/12cc1a39.html"/>
      <url>/post/12cc1a39.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是gRPC协议"><a href="#什么是gRPC协议" class="headerlink" title="什么是gRPC协议"></a>什么是gRPC协议</h1><p><a href="https://grpc.io/">gRPC</a> 是一个由Google开发的高性能开源的RPC框架，基于HTTP&#x2F;2协议标准设计，支持GO，C++，JAVA，Python等多种语言。我们之前已经介绍过了RPC框架，见<a href="https://null-528.github.io/post/b9eb0f9.html">详解RPC</a>，gRPC整体流程和RPC是完全一致的：</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/grpc%E8%B0%83%E7%94%A8.svg" alt="grpc调用"><br>gRPC使用谷歌自家开源的Protocol Buffers(protobuf)作为信息描述格式。因此我们需要先来学习一下protobuf。</p><h1 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h1><p>协议缓冲区Protobuf(Protocol Buffers)是一种免费开源的跨平台数据格式，用于序列化结构化数据。（From <a href="https://en.wikipedia.org/wiki/Protocol_Buffers">Wiki</a>）它与 JSON 或XML 类似，只是体积更小、速度更快，而且能生成本地语言绑定。</p><p>在通信管道上，protobuf 使用ASCII码，通过纯二进制的方式进行传输。由于其紧凑的数据结构，在传输数据时，能够节省带宽、提高传输性能，但同时也意味着相比 JSON 和 XML 这种字符文本形式，protobuf丧失了可读性，也就是说，如果没有外部规范文件.proto，就无法知道字段的名称、含义或完整数据类型。</p><p>由于上述特性，protobuf非常适合用于高效RPC传输的场景。发送端和接收端使用相同的一份.proto文件，发送端将数据通过.proto文件中定义的格式对数据进行序列化，然后发送给接收端，接收端通过.proto文件对数据进行反序列化。</p><h1 id="protobuf详解"><a href="#protobuf详解" class="headerlink" title="protobuf详解"></a>protobuf详解</h1><p>例如我们有一个后缀为 .proto 的普通文本文件，里面定义了Field对象的相关字段：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> xxx.proto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;xxx.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Field</span> &#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> metric = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> field = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Type</span> &#123;</span><br><span class="line">        IMAGES = <span class="number">0</span>;</span><br><span class="line">        WEB = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字段</th><th>含义</th></tr></thead><tbody><tr><td align="center">syntax</td><td>protobuf的版本，目前支持proto2和proto3，默认为proto2。在我们这篇文章中的case都使用proto3版本</td></tr><tr><td align="center">package</td><td>用来声明包避免命名冲突，如果使用的是JAVA，那么等效于java_package。</td></tr></tbody></table><blockquote><p>在不同的语言中都有不同option来定制化一些内容，例如java还有：</p><ul><li>java_multiple_files：默认为false。设置是否生成多个文件，如果为true，那么每个message对象都会生成一个.java文件。</li><li>java_outer_classname：在单文件的情况下，设置生成的.java文件名称，即多个message对象的外部类名称。如果没有设置的话，会将.proto文件名的驼峰写法作为文件名。</li><li>java_generate_equals_and_hash：默认false，设置是否生成equals和hashCode方法。</li><li>java_generic_services：默认false，设置是否生成泛型服务。</li></ul><p> 其他语言中也有对应的option，例如：</p><ul><li>csharp_namespace：设置C#的命名空间。</li><li>go_package：设置Go的包名。</li><li>py_generic_services：默认false，设置是否开启Python的泛型服务。</li><li>ruby_package：设置Ruby的包名。</li></ul><p>需要注意，proto2和proto3具体option是有区别的，具体可以参考[官方文档](<a href="https://developers.google.com/protocol-buffers/docs/proto%EF%BC%89">https://developers.google.com/protocol-buffers/docs/proto）</a></p></blockquote><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>很多标准的简单数据类型供字段可用，常用的有double、float、uint32、uint64、bool、string、bytes、uint32、uint64、enum以及其他在文件中定义的message类型。</p><ul><li>int32、int64：如果负数指定这两个类型编码效率较低。负数应该使用下面的类型。</li><li>sint32、sint64：对负数会进行ZigZag编码提高编码效率。</li><li>fixed32、fixed64：总是4字节和8字节</li><li>sfixed32、sfixed64：总是4字节和8字节</li><li>enum：枚举类型，对应的字段编号必须从0开始，其对应的枚举值会作为默认值。</li></ul><p>因为采用Varint编码4个字节能表示的最大数字就是228-1了，超过这个值就需要5个字节来表示。因此对于大于228-1的数，采用固定长度fixed32或者fixed64的效率会更高。</p><h2 id="字段编号"><a href="#字段编号" class="headerlink" title="字段编号"></a>字段编号</h2><p>需要给每一个字段赋予一个整数作为编号，用来唯一指定二进制中的field。传输的时候只会使用这个编号，具体的信息，如字段名称、类型等，是通过传输双方共有的.proto文件来确定的。这样就节省了一些带宽空间，也避免了不同语言中表示字段类型大小不同的冲突。</p><p>所以编号一旦正式使用就不支持修改,<strong>否则就相当于删除了这个字段，然后创建了一个相同类型但不同编号的新字段</strong>。就算真的要删除这个字段，这个字段在使用时忽略即可，不要删除，否则可能导致新增字段不小心重复编号。</p><p>使用限制：</p><ol><li>给定的编号在该对象的所有字段中必须是唯一的。</li><li>字段编号 19,000 至 19,999 保留给协议缓冲区实现。如果在报文中使用了这些保留字段编号，协议缓冲区编译器将发出报警。<blockquote><p>一般我们会从1开始依次递增+1编号，因为较低的字段编号传输时中占用的空间较少。例如，字段编号范围为 1 至 15 的字段编号只需一个字节进行编码。16 至 2047 范围内的字段编号需要两个字节。</p></blockquote></li></ol><h2 id="字段规则"><a href="#字段规则" class="headerlink" title="字段规则"></a>字段规则</h2><p>目前支持optional和required、repeated。</p><ul><li>optional表示该字段非必填，可以为空。</li><li>required表示该字段必填，不能为空。</li><li>repeated表示该字段可以重复多次，包括零次，相当于数组。</li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>上面代码已经体现，protobuf的数据结构格式（schema）叫做message，它表示定义一个对象,一个消息(message)是包含一系列类型字段的k-v对。想象我们需要将这些数据序列化为二进制串，那么需要知道每个字段对应的起止位置、名称和对应的值。</p><p>所以<strong>报文的二进制版本会将字段编号作为键，解码端通过.proto文件来确定每个字段的名称和声明类型。</strong>即以T-L-V（Tag - Length - Value）表示单个字段field，最终将所有数据拼接成一个紧凑的字节流：</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/TLV.webp" alt="protobuf使用的TLV"></p><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>先来看Tag，它由两部分组成，最后整体通过Varints编码：</p><ul><li>field_number：字段编号，见1.1.2节。</li><li>wire_type：protobuf编码类型，目前protobuf定义了6种，见上表（其中Start group和End group已经被废弃）。序列化和反序列化时会选择对应的编码方式，编码对象为最终的Value。</li></ul><p>tag至少占用一个1字节，如果field_number大于15，那么需要多占用2个字节。其中最高位用于Varint编码保留，确认下一个字节是否需要。另外wire_type占用4个bit，field_number占用剩余的bit。</p><h3 id="Length-Value"><a href="#Length-Value" class="headerlink" title="Length &amp; Value"></a>Length &amp; Value</h3><p>length表示Value的长度，但并不是必填，可以根据message使用的数据类型来判断value长度。<strong>但如果tag中选择wire_type为Length-delimited，那么表示value是变长的数据类型，如string，所以length是必填的。</strong></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>前文提过，protobuf现在支持的编码方式只有4种，分别是Varint、Fixed32、Fixed64和Length-delimited。对于文本类型，直接根据ASCII码转为二进制即可，但对数字类型稍微复杂些：</p><h3 id="Varint"><a href="#Varint" class="headerlink" title="Varint"></a>Varint</h3><p>Varint编码方式是最常用的数字编码方式，举个例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int32 a = 251;</span><br><span class="line"></span><br><span class="line">数字251的二进制补码表示为：</span><br><span class="line">0000 0000 0000 0000 0000 0000 1111 1011</span><br><span class="line"></span><br><span class="line">使用varint编码：</span><br><span class="line">1.以7位1组单位逆序：</span><br><span class="line">111 1011 000 0001 0000 0000 0000 0000 00</span><br><span class="line"></span><br><span class="line">2.7位1组，第一位高位为msb(most significant bit)表示是否需要下一个字节，这里第一个字节需要下一个字节，故第一个字节补高位为1。第二个字节不需要第三个字节了，故第二个字节补高位为0</span><br><span class="line">1111 1011 0000 0001 0000 0000 0000 0000 00</span><br><span class="line"></span><br><span class="line">故数字251的varint编码为：</span><br><span class="line">1111 1011 0000 0001</span><br><span class="line"></span><br><span class="line">十六进制表示为：</span><br><span class="line">0xFB01</span><br></pre></td></tr></table></figure><p>可以看到，每个字节中的最高位都需要保留，因此4个字节最多可以表示2^28-1，超过这个数就需要增加一个字节，降低一定编码效率。</p><h3 id="ZigZag"><a href="#ZigZag" class="headerlink" title="ZigZag"></a>ZigZag</h3><p>另外，容易想到，如果要表示的负数，原来的最高位是符号位，这样就发生了冲突，或者占用2个bit就进一步压缩了能表示的数字范围，会有更大的几率需要增加额外字节，因此Varint编码方式只适用于正数，对于负数，需要使用ZigZag编码，<strong>有符号整数映射到无符号整数，然后再使用 Varints 编码。</strong>映射关系为：</p><ul><li>Zigzag(n) &#x3D; (n &lt;&lt; 1) ^ (n &gt;&gt; 31),  n为sint32时</li><li>Zigzag(n) &#x3D; (n &lt;&lt; 1) ^ (n &gt;&gt; 63),  n为sint64时</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = -1;</span><br><span class="line"></span><br><span class="line">-1的二进制编码：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">n &lt;&lt; 1后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line"></span><br><span class="line">n &gt;&gt; 31后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">故(n &lt;&lt; 1) ^ (n &gt;&gt; 31)后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111----两行执行不进位的半加操作</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">故:Zigzag(-1) = 1;</span><br></pre></td></tr></table></figure><h2 id="反序列化解析"><a href="#反序列化解析" class="headerlink" title="反序列化解析"></a>反序列化解析</h2><p>那么对于一整个message结构体:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个根据这个.proto文件生成的二进制串：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">十六进制：</span><br><span class="line">0a06 5374 6576 656e</span><br><span class="line"></span><br><span class="line">二进制表示为：</span><br><span class="line">00001010 00000110 01010011 01110100 01100101 01110110 01100101 01101110</span><br></pre></td></tr></table></figure><p>先分析前两个字节，在这个case中即tag和length</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/deserialize.png"></p><p>再来看value，即后面的6个字节，分别对应ASCII码：<code>83 116 101 118 101 110</code>，对照ASCII码表得到的字符串为： <code>Steven</code>。</p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>除了message之外，proto文件中还可以定义service，用来定义远程调用的方法：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">Computer</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ping (Empty) <span class="keyword">returns</span> (ServerStatus) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> compute (stream ComputeRequest) <span class="keyword">returns</span> (stream ComputeResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的service中定义了两个方法，我们分别来看一下：</p><h2 id="简单rpc"><a href="#简单rpc" class="headerlink" title="简单rpc"></a>简单rpc</h2><p>ping()方法，参数为Empty，返回值为ServerStatus。具体这两个对象需要在.proto文件中去详细定义。整个过程和平常的函数调用一样。</p><h2 id="流式rpc"><a href="#流式rpc" class="headerlink" title="流式rpc"></a>流式rpc</h2><p>注意到第二个方法，compute()，参数为stream ComputeRequest，返回值为stream ComputeResponse。通过在参数和返回值前加上stream关键字，表示这是一个流式rpc。</p><ul><li>如果只在入参部分使用stream关键字，说明是一个客户端流式RPC，即客户端使用流将一个消息序列发送给服务端，然后服务端返回一个响应；</li><li>反过来，如果只在返回值部分使用stream关键字，说明是一个服务端流式RPC，即客户端在发送请求后，使用流从服务端获取响应，直到流中没有其他消息为止。</li><li>如果同时使用stream关键字，则表示双向流式RPC，即客户端和服务端都使用流将消息序列发送和接收。这两个流是独立操作的，因此客户端和服务器可以按任意顺序发送和接收消息。比如：服务器可以在写入响应前等待接收到所有的请求消息，或者可以交替读取和写入消息，或者以任何顺序读取和写入。</li></ul><h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><p>可以看到，message这种结构体在传输时，需要一次性加载到内存中进行解析，因此只适合用于传输几兆字节的小数据块，如果报文太大，应该考虑其他的方法，比如流式传输。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解RPC</title>
      <link href="/post/b9eb0f9.html"/>
      <url>/post/b9eb0f9.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>在最早的时候，进程只能获取自己栈帧内的数据，例如有2个进程，两者是无法数据通信的。为了解决这个问题，出现了本地进程间通信IPC（Inter-Process Communication）技术，通过如共享内存，管道等手段，来交换数据。但后来业务逐渐复杂，磁盘、CPU等资源逐渐达到瓶颈，人们开始考虑将多台计算机组成一个集群来提高服务的吞吐能力，这就是分布式。</p><p>RPC（Remote Procedure Call），即远程程序调用，可以理解为RPC是将进程间通信的范围从单机扩大到了一个共享网络中，这样不同服务间调用方法像同一服务间调用本地方法一样，而不需要调用者了解底层网络技术的协议。如cassandra集群节点接通信，以及SpringCloud 微服务中各个服务之间的通信。</p><p>RPC 现在所指的概念也有些模糊，一般来说我们将其理解为一种request-response的网络传输思想，但在wiki等一些网站上，rpc也可以狭义地理解为一种协议，并且需要通过stub等动态代理来实现消息传输。</p><h1 id="RPC协议模型"><a href="#RPC协议模型" class="headerlink" title="RPC协议模型"></a>RPC协议模型</h1><p>这里介绍在wiki等网站<strong>狭义</strong>定义的RPC协议模型：<br><img src="/../images/%E8%AF%A6%E8%A7%A3RPC/rpc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpeg" alt="rpc调用"><br>整个过程可以分为以下几个阶段：</p><ol><li>客户机调用本地的Stub，将参数传递进去。</li><li>Stub将参数marshall（打包）到消息中。这个过程包括将参数标准化的过程。</li><li>Stub将消息传递给传输层，再由传输层发送到远程服务器机器。</li><li>服务器的Stub收到消息后，存根对参数进行unmarshall（解包），然后根据参数调用本地服务。</li><li>服务器服务完成调用后，将结果参数返回给服务器Stub，服务器Stub再将结果参数标准化并marshall（打包）到消息中。</li><li>服务器Stub将消息传递给传输层，传输层再发送给客户端Stub。</li><li>客户端Stub解析参数，将结果返回给调用者。</li></ol><p>在上面的流程中，看上去两个进程是1对1同步阻塞的，但实际上rpc并没有限制异步调用，可以选择异步来提高并发。</p><blockquote><p>这里用Stub存根来指代远程服务的本地代理程序或者软件，它是客户端和应用程序的中间层，用于处理一些调用细节如负责封装请求、解析响应、处理网络通信等。例如在java中，Stab就是通过动态代理技术实现的。</p><p>Stub一般都是RPC框架自动生成的，开发者不需要关心。</p></blockquote><h1 id="RPC系统"><a href="#RPC系统" class="headerlink" title="RPC系统"></a>RPC系统</h1><p>为了让不同的客户端访问服务器，人们创建了许多标准化的 RPC 框架。这些框架大多使用接口描述语言IDL(Interface description language)来让各种平台调用 RPC。IDL 文件随后可用于生成客户端与服务器之间的接口代码。目前有以下这些常见的 RPC 框架：</p><ol><li><p>gRPC：由Google开发的高性能、跨语言的RPC框架，基于HTTP&#x2F;2协议，支持多种语言，如C++, Java, Python, Go等。gRPC使用Protocol Buffers作为默认的序列化协议，支持双向流、流式处理等特性。</p></li><li><p>Apache Thrift：由Facebook开发的跨语言的RPC框架，支持多种语言，如C++, Java, Python, PHP等。Thrift使用自定义的IDL（Interface Definition Language）来定义服务接口，支持多种传输协议和序列化协议。如cassandra执行cql时使用的就是Thrift。</p></li><li><p>Apache Dubbo：由阿里巴巴开发的高性能、轻量级的RPC框架，支持多种语言，如Java, Go, Python等。Dubbo提供了丰富的功能，如负载均衡、服务注册与发现、服务治理等。但官网的性能测试数据可能并不准确，实际使用中性能表现不如gRPC，可以参考<a href="https://coolshell.cn/articles/17381.html">性能测试应该怎么做？</a></p></li></ol><h1 id="其他常见概念"><a href="#其他常见概念" class="headerlink" title="其他常见概念"></a>其他常见概念</h1><h2 id="Restful-RPC"><a href="#Restful-RPC" class="headerlink" title="Restful &amp; RPC"></a>Restful &amp; RPC</h2><p>两者不是可以放在一起比较的概念。<br>Restful，即 Representational State Transfer(表现层状态转移)，是一种设计风格，它面向资源，对接口做出了一系列要求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取所有用户： GET /users</span><br><span class="line">获取指定用户： GET /users/&#123;<span class="built_in">id</span>&#125;</span><br><span class="line">创建用户：    POST /users</span><br><span class="line">更新用户：    PUT /users/&#123;<span class="built_in">id</span>&#125;</span><br><span class="line">删除用户：    DELETE /users/&#123;<span class="built_in">id</span>&#125;</span><br></pre></td></tr></table></figure><p>从宏观来讲，RPC是一种网络通信思想，而Restful是一种API规范。RPC本身并不限制实现框架的传输协议，只要是基于传输层之上的就可以。但Restful一定都是作用于HTTP&#x2F;HTTPS协议之上的。</p><h2 id="MQTT-RPC"><a href="#MQTT-RPC" class="headerlink" title="MQTT &amp; RPC"></a>MQTT &amp; RPC</h2><p>从定义来讲，MQTT的发布订阅模式并不完全符合RPC『远程程序调用』的定义，即MQTT的接收方不会返回调用运行计算结果。笔者认为这应该是两种网络通信方式。<br>另外，从定义来讲，RPC要求调用方和被调用方必须同时存在，而MQTT是发布订阅模式，即消息的发送者不需要知道消息接收者的存在。PC是一对一，MQTT是多对一。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Java系列】代理</title>
      <link href="/post/53c8b77c.html"/>
      <url>/post/53c8b77c.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h1><p>   在编译时期无法确定需要实现哪个接口时，我们可以使用代理，在运行时创建实现一组给定接口的新类。对于编写应用程序的程序员来说这种场景比较少见，但对某些系统应用程序，代理带来的灵活性十分重要。</p><p>   总体来说，代理就是为某些对象的某种行为提供一个代理对象，并由代理对象完全控制该行为的实际执行。代理分为静态代理和动态代理两类，两者的主要区别就是代理类生成的时机，其中：</p><ul><li>静态代理：在程序运行前，创建代理类，实现代理逻辑，编译时就已经实现了，编译完成后代理类成为一个实际的class文件。</br></li><li>动态代理：在程序运行时，运用反射机制动态创建代理类，编译时没有实际的class文件，而是在运行时动态生成字节码。</br></li></ul><p>特别地，动态代理又有两种主要的实现方式，分别为：JDK 动态代理和 CGLIB 动态代理。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>   当我们需要在不修改目标对象的前提下，扩展目标对象的功能，就可以使用静态代理。例如：</p><p>我们有一个接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个目标对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDao</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们的静态代理对象可以这么构建，可以看出，静态Proxy相当于将要代理的对象封装了一层，重写并嵌套使用其所有的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IHello target；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(IHello target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">        target.sayHello();</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>   假如我们要构造一个类的对象，这个类实现了1个或多个接口，但在编译时期，可能并不知道这些接口是什么，这个时候就可以使用动态代理来解决我们的问题。动态代理有两大类：JDK和CGLIB，两者最大的不同是JDK需要代理的对象是基于接口实现的，而CGLIB作为第三方代码生成的类库，没有这种需求。</p><p>   动态代理基本会代理所有的代理对象的方法,对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发，例如getClass()、clone()方法。 </p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>   JDK 动态代理就是基于 JDK 实现的代理模式，主要运用了其拦截器和反射机制，其代理对象是由 JDK 动态生成的，而不像静态代理方式写死代理对象和被代理类。JDK 代理是不需要第三方库支持的，只需要 JDK 环境就可以进行代理，使用条件：</p><ul><li>必须实现InvocationHandler</li><li>使用Proxy.newProxyInstance产生代理对象</li><li>被代理的对象必须实现一个或多个接口</li></ul><blockquote><p>使用 JDK 动态代理的五大步骤：</br><br>1.通过实现InvocationHandler接口来定义自己的InvocationHandler</br><br>2.通过Proxy.getProxyClass获得动态代理类</br><br>3.通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)</br><br>4.通过构造函数获得代理对象并将自定义的InvocationHandler实例对象为参数传入</br><br>5.通过代理对象调用目标方法。</br></p></blockquote><p>  接下来，我们就按上面的 5 个步骤，写一个 JDK 动态代理的示例。</p><ul><li>PersonProxyFactory，HelloImpl的代理类，这个代理类中需要实现InvocationHandler接口的invoke方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IHello <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> invocationHandler();</span><br><span class="line">        <span class="comment">// 传入代理目标使用的类加载器、代理目标实现的接口类型、对应的事件处理器。</span></span><br><span class="line">        <span class="keyword">return</span> (IHello) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InvocationHandler <span class="title function_">invocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现InvocationHandler接口的invoke方法</span></span><br><span class="line">        <span class="keyword">return</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(instance, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>MyProxyTest，测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PersonProxyFactory</span> <span class="variable">personProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxyFactory</span>(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">        personProxyFactory.createProxy().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。它广泛地被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</p><p>还是之前的几个例子，我们实现CGLIB的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibPersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CGLibPersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB HELLO WORLD !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>在动态代理的过程中，如果被代理的对象的执行方法抛错，调用方会得到InvocationTargetException类的异常，这个异常封装了实际的问题，需要使用getTargetException()方法将内容取出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】存储器</title>
      <link href="/post/947584e1.html"/>
      <url>/post/947584e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要有存储器"><a href="#为什么要有存储器" class="headerlink" title="为什么要有存储器"></a>为什么要有存储器</h1><p>我们知道，计算机中的主要存储设备包括了cache、主存、辅存，容量依次增大，速度依次减慢。<br>主存需要存储正在执行的程序和大量数据（CPU寄存器也会存储一小部分）。在如今这种计算机有大量输入输出设备的前提下，为了快速传输数据，支持存储器与输入输出设备之间直接传输数据，这种技术叫DMA直接存储器存储。</p><h1 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h1><h2 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h2><p>容量：即主存最大寻址范围。如，32位微型机提供32位物理地址，即支持2^32&#x3D;4G主存空间。<br>存取时间：存储器访问时间，指启动一次存储器操作到完成该操作所用的时间。<br>存取周期：值连续启动两次独立的存储器操作（例如连续两次读取操作）所需要的最小时间。通常存储周期略大于存取时间。<br>但相比与高速的CPU，主存的读取还是慢了非常多。由于指令存储在主存，因此可能出现存储速度跟不上CPU处理指令和数据的速度。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="RAM易失性存储器"><a href="#RAM易失性存储器" class="headerlink" title="RAM易失性存储器"></a>RAM易失性存储器</h3><p>RAM又称读写存储器，CPU缓存、电脑缓存和手机内存基本都属于RAM。RAM根据能否长时间保存数据，又分为动态RAM和静态RAM：<br>动态RAM：通过MOS电容是否存储电荷表达信息，在断开电源后，电容会放电，因此存储的数据在断电后丢失。<br>静态RAM：通过触发器门电路存储信息，需要使用6个或者更多的晶体管构成特殊电路来表达1个bit。触发器断电后，就会失去存储的数据。<br><strong>静态RAM集成度低，功耗大，速度快；动态RAM集成度高，功耗小，价格低廉，因此适合用于大容量存储</strong>。</p><h3 id="ROM非易失性存储器"><a href="#ROM非易失性存储器" class="headerlink" title="ROM非易失性存储器"></a>ROM非易失性存储器</h3><p>固态硬盘、U盘、买手机说的32G、64G存储空间就属于ROM。<br>ROM即叫Read Only Memory，在厂商制造时写入数据，然后不可更改了（熔丝已经被焊死了），例如BIOS就在ROM上，早期的CD、DVD也都属于ROM。</p><blockquote><p><strong>但实际上现在主要使用的ROM也有很多种可写的</strong>：<br>PROM(Programmable ROM)可编程只读寄存器，如一些英语学习机，厂商造出存储器后卖给学习机工厂，学习机工程师再只写入一次数据，然后就只读了。也就是说，熔丝刚开始是全部接通的，用户可以按需求断开部分熔丝（也就是我们说的烧到板子上）。<br>EPROM(Erasable programmable ROM)可擦可编程只读存储器，通过紫外线擦除电荷，编程次数不受限制。<br>EEPROM(Electrically erasable programmable ROM)电子式可擦可编程只读存储器，通过电擦除电荷，但重复改写次数有限，大概10w上下。<br>Flash Memory：闪存。电擦除且次数不受限制，具有大容量、非易失、低价格的特点。<br>例如我们现在手机内存，用的都是可重复写入的ROM了。</p></blockquote><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>一般我们使用半导体动态RAM作为计算机主存（即内存），存放正在执行的程序和数据<br>磁盘、磁带、光盘、U盘、</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】基础</title>
      <link href="/post/60fe0c4f.html"/>
      <url>/post/60fe0c4f.html</url>
      
        <content type="html"><![CDATA[<h1 id="信息的表达"><a href="#信息的表达" class="headerlink" title="信息的表达"></a>信息的表达</h1><blockquote><p>思考: 我们为什么需要计算机？它是用来解决什么问题的？</p><p>本质上就是我们采用可操作的电路，来运输、计算和记录信息。为了实现这个目标，我们需要思考如何将信息通过合理的形式，在电路上进行表达（甚至后续进行的进行检测和修复）。</p></blockquote><p>我们需要将概念落地工程化。首先，怎样在电路中表达信息？<br>正如电路有连通和断开两种情况一样，我们用1和0来表达这两种信息。在足够小又足够多的电路中，我们就能有大量的0和1。正如英文有26个字母，只要我们将信息和字母排列组合做出映射（单词表），那么我们就能够表达丰富的语言一样，0和1作为2个基础字母，在计算机世界中也就能表达各种各样的含义。再加上一些逻辑原件，那么就可以进行相关的计算了！</p><h1 id="计算机的出现"><a href="#计算机的出现" class="headerlink" title="计算机的出现"></a>计算机的出现</h1><blockquote><p>比如第一台电子计算机ENIAC（electronic numerical integrator and computer）电子数值积分计算机，是1943-1946美国宾夕法尼亚大学研制的，有<strong>18000多个电子管，1500个继电器，重达30吨，占地约170平方米，耗电140kw</strong>，每秒能计算5000次加法。这台计算机是美国陆军部资助研发的，二战期间用于辅助新武器弹道计算。 </p><p>它的缺点是只能存20个长度为10位的十进制数，并且需要人工改线路连接来编排程序，计算准备时间大大超过实际使用时间，故障排查也很费精力。<br>我们常常将计算机故障称为bug，也是由于这个阶段中电路和原件可能由于小飞虫进度出现故障。</p></blockquote><h2 id="计算机基础架构"><a href="#计算机基础架构" class="headerlink" title="计算机基础架构"></a>计算机基础架构</h2><p>与此同时冯诺依曼和莫尔小组合作研制EDVAC计算机，特点是不需要人工修改线路，而是将指令（程序）存储起来，计算机按照指令顺序执行，每步骤的计算结果放入存储器中。其后在相当长的一段时间内开发的计算机都和EDVAC计算机的方案保持一致，我们称为<strong>冯诺依曼型计算机</strong>，一般是由5个部分构成：<strong>运算器、控制器、存储器、输入设备和输出设备</strong>。<br>（1）采用二进制表达信息；<br>（2）将数据和指令都以二进制的方式存储在存储器中；<br>（3）运算器是整个机器的核心，输入输出设备与存储器件中的数据运输都是通过运算器。<br>（4）指令由操作码和地址码构成。<br>（5）指令在存储器中按照执行顺序存放，由指令计数器（即程序计算器PC）指明要执行指令所在的存储单元地址，一般按照顺序递增，但可按运算结果或外界条件改变。<br>我们说的CPU，实际上包含了运算器和控制器。</p><blockquote><p>计算机的整体架构就比较明确了，接下来同样的，我们要解决的是工程落地问题，为了实现这些内容，我们会问出以下问题：<br>（1）怎样用二进制表达信息，如何用最小的成本表达最多的信息？<br>（2）什么是存储器，它是怎样存储二进制信息的，以及如何在有电&#x2F;断电情况下继续保持信息？<br>（3）运算器有哪些，分别有什么作用？<br>（4）指令是怎样执行的？PC如何选择要执行的指令，在执行故障时如何中断程序并给出信息？<br>（5）如何在运行过程中允许监听外部指令，做到对用户指令进行反馈？</p></blockquote><p>带着上面的问题，后面的文章也大概分为了四章，带着我的理解尽量解释。在这个过程中不可避免地会涉及到其他材料、数字逻辑、信息论内容，我们会简单提一下，如果要研究清除这一个个问题真的会花费不少的精力。</p><h1 id="计算机的发展"><a href="#计算机的发展" class="headerlink" title="计算机的发展"></a>计算机的发展</h1><p>我们一般根据计算机使用的物理器件来划分电子计算机发展史（注意电子计算机之前还有卡片机，在卡片上打孔），一般划分为这5个阶段，相邻阶段之间可能有部分时间重叠。</p><h2 id="电子管计算机时代（1940是-1950s）"><a href="#电子管计算机时代（1940是-1950s）" class="headerlink" title="电子管计算机时代（1940是~1950s）"></a>电子管计算机时代（1940是~1950s）</h2><p>1940s第一台电子计算机ENIAC由于军事需求研制，二战结束后美国IBM公司崛起，1954年开始推出IBM650小型机，1958年IBM709大型机是IBM公司性能最高的最后一台电子管计算机。</p><h2 id="晶体管计算机时代（1950s-1960s）"><a href="#晶体管计算机时代（1950s-1960s）" class="headerlink" title="晶体管计算机时代（1950s~1960s）"></a>晶体管计算机时代（1950s~1960s）</h2><p>晶体管和电子管（真空管）都是电信号放大的元器件，晶体管出现更晚一些，是1947年贝尔实验室的肖克利团队造出了第一个晶体管，比电子管体积更小，寿命更长，价格更便宜，功耗更低。<br>电子管是通过热电子发射阴阳极之间的电场来控制电流的，为了避免热损耗，单个晶体管的发热材料需要套在一个真空内壳里，这就决定了晶体管的体积不会太小，并且也更容易坏。而现代1个5纳米的芯片上甚至可以有百亿个晶体管，因此晶体管基本已经取代了电子管的地位。<br>1960~1964年CDC公司研制了大型高速计算机系统CDC6600，深受美国和西欧各原子能、宇宙、航空、气象研究和大学的欢迎。1969年的CDC7600计算速度更是达到了每秒千万次浮点运算。</p><h2 id="集成电路计算机时代（1960s-1970s）"><a href="#集成电路计算机时代（1960s-1970s）" class="headerlink" title="集成电路计算机时代（1960s~1970s）"></a>集成电路计算机时代（1960s~1970s）</h2><p>集成电路可以理解为最早的芯片雏形。将多个晶体管、电容、电阻在硅芯片上互联，相比晶体管，体积、功耗、成本进一步下降，因此计算机的体积进一步缩小了，也在市场上开始进一步流通小型机。<br>如IBM360系统，型号有小中大三种，运算速度也是从每秒几千次到每秒百万次。</p><h2 id="大规模集成电路计算机时代（1970s-1980s）"><a href="#大规模集成电路计算机时代（1970s-1980s）" class="headerlink" title="大规模集成电路计算机时代（1970s~1980s）"></a>大规模集成电路计算机时代（1970s~1980s）</h2><p>在半导体晶体管后，人们又发明了半导体存储器替代磁芯存储器，著名的摩尔定律就是这个时候提出的。1971年，Intel4004芯片问世，小型机的性能进一步提升，更广泛地应用于各种高精尖行业中。<br>同时家用计算机也开始兴起，1977年Apple推出了Apple II微机，1981年IBM公司推出了IBM PC。</p><h2 id="超大规模集成电路计算机时代（1980s-now）"><a href="#超大规模集成电路计算机时代（1980s-now）" class="headerlink" title="超大规模集成电路计算机时代（1980s~now）"></a>超大规模集成电路计算机时代（1980s~now）</h2><p>目前，高性能微处理器芯片所含的晶体管数量突破亿级，Apple的A16芯片更是集成160亿晶体管。智能手机等更小型设备也进入了人们的生活，从而形成了互联网出现的基本前提。</p><p>现在的计算机也不仅仅用于单纯数据计算，还有很多软件服务，因此我们补充一下计算机系统结构：</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.jpg" alt="计算机整体架构"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【开发工具】Markdown语法</title>
      <link href="/post/3c50d03d.html"/>
      <url>/post/3c50d03d.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Markdown 由 John Gruber 和 Aaron Swartz 于 2004 年创建，目标是创造一种web文本格式，尽可能方便人们阅读和写作。但起初它的设计主要针对一些简单日常的使用场景，并支持用户通过内联html来支持未涵盖到的语法，见<a href="https://daringfireball.net/projects/markdown/syntax">Markdown基本语法</a>。后来一些个人和组织开始通过添加其他元素来扩展基本语法，很多的Markdown处理器使用的都是拓展后的语言，例如Typora 使用的是<a href="https://github.github.com/gfm/">GitHub Flavored Markdown(GFM)</a>。</p><blockquote><p>John Gruber（1973-？） 是一个美国宾夕法尼亚州的技术博主，也是苹果公司的狂热粉丝，后来通过全职运行他的独立博客<a href="https://daringfireball.net/">Daring Fireball</a>，和有声杂志The talk show，分享他的技术见解和苹果产品的最新消息和点评。</p></blockquote><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>通过不同个数的『#』来设置标题，最多支持六级标题。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br><span class="line">####### 不支持七级标题</span><br></pre></td></tr></table></figure><p>其中，一级和二级标题还有一种写法：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">===================</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">--------------------</span></span><br></pre></td></tr></table></figure><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>一般段落，通过换行来创建即可。在idea中可以通过setting-&gt;editor-&gt;general-&gt;soft wrap来设置全局自动换行。有需要强制换行的，通过在行尾添加<code>&lt;/br&gt;</code>来强制换行。</br><br>另外，段落<strong>不支持</strong>使用空格或tab来缩进。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>通过<code>&gt;</code>来进行块引用，支持嵌套。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">这是一层引用</span></span><br><span class="line">&gt;&gt; 这是二层引用（后面空一行表示结束第一层引用）</span><br><span class="line"><span class="meta prompt_">&gt;</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">回到第一层引用</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">### 可以添加*标题*</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">- 和其他元素</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这是一层引用</p><blockquote><p>这是二层引用</p></blockquote><p>回到第一层引用</p><h3 id="可以添加标题"><a href="#可以添加标题" class="headerlink" title="可以添加标题"></a>可以添加标题</h3><ul><li>和其他元素，但是是否渲染以及渲染效果取决于使用的解析器。</li></ul></blockquote><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>无序列表通过<code>-</code>、<code>+</code>或<code>*</code>来创建，支持嵌套。有序列表通过数字加<code>.</code>来创建，支持嵌套和相互嵌套。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是无序列表</span><br><span class="line"><span class="bullet">-</span> 无序1</span><br><span class="line"><span class="bullet">    -</span> 嵌套1</span><br><span class="line"><span class="bullet">+</span> 无序2</span><br><span class="line"><span class="bullet">*</span> 无序3</span><br><span class="line">这是有序列表</span><br><span class="line"><span class="bullet">1.</span> 有序1</span><br><span class="line"><span class="bullet">   1.</span> 嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)</span><br><span class="line"><span class="bullet">      -</span> 无序和有序可以相互嵌套</span><br><span class="line"><span class="bullet">2.</span> 有序2</span><br></pre></td></tr></table></figure><p>效果：</br><br>这是无序列表</p><ul><li>无序1<ul><li>嵌套1</li></ul></li></ul><ul><li>无序2</li></ul><ul><li>无序3</li></ul><blockquote><p>一般来说，同一个列表中最好不要混用不同的分隔符，否则有些解析器可能会识别混乱造成渲染错误。</p></blockquote><p></br>这是有序列表</p><ol><li>有序1<ol><li>嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)<ul><li>无序和有序可以相互嵌套</li></ul></li></ol></li><li>有序2</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>通过反引号『&#96;』来创建行内代码，不支持嵌套。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`hello world!`</span></span><br></pre></td></tr></table></figure><p>效果：<code>hello world!</code><br/><br>一般情况下我们都使用反斜杠<code>\</code>进行转义，但特别地，如果要对反引号进行转义，需要通过双反引号。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">``Use `code` in your Markdown file.``</span><br><span class="line">`` `hello world!` ``</span><br></pre></td></tr></table></figure><p>效果：<code>Use `code` in your Markdown file.</code> <code>`hello world!`</code> </p><p>通过前后2个『&#96;&#96;&#96;』来创建封闭的代码块，在起始的三个”&#96;”后可以表明使用的语言（小写），来进行语法高亮。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHello</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法高亮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>使用<code>*</code>或<code>_</code>来设置斜体，使用<code>**</code>或<code>__</code>来设置加粗，使用<code>***</code>或<code>___</code>来设置斜体加粗，使用<code>~~</code>来设置删除线。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*斜体*</span></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="emphasis">__加粗__</span></span><br><span class="line"><span class="strong">***斜体加粗**</span>*</span><br><span class="line"><span class="emphasis">___斜体加粗__</span>_</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：<br><em>斜体</em><br><em>斜体</em><br><strong>加粗</strong><br><strong>加粗</strong><br><em><strong>斜体加粗</strong></em><br><em><strong>斜体加粗</strong></em><br><del>删除线</del></p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="外部url直接引用"><a href="#外部url直接引用" class="headerlink" title="外部url直接引用"></a>外部url直接引用</h2><p>通过&lt;&gt;可以直接创建外部引用链接。如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:<span class="comment">//baidu.com/&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<a href="https://baidu.com/">https://baidu.com/</a>。</br><br>如果需要添加说明，可以通过<code>[说明](url)</code>来创建外部链接，同样地，可以对链接字体进行设置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com/</span>)</span><br><span class="line"><span class="strong">**[<span class="string">加粗</span>](<span class="link">https://baidu.com/</span>)**</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">粗斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line">~~[<span class="string">删除线</span>](<span class="link">https://baidu.com/</span>)~~.</span><br><span class="line">[<span class="string">`行内代码`</span>](<span class="link">https://baidu.com/</span>).</span><br></pre></td></tr></table></figure><p>效果：<br><a href="https://baidu.com/">百度</a><br><strong><a href="https://baidu.com/">加粗</a></strong>.<br><em><a href="https://baidu.com/">斜体</a></em>.<br><em><a href="https://baidu.com/">粗斜体</a></em>.<br><del><a href="https://baidu.com/">删除线</a></del>.<br><a href="https://baidu.com/"><code>行内代码</code></a>.</p><h2 id="参考链接引用"><a href="#参考链接引用" class="headerlink" title="参考链接引用"></a>参考链接引用</h2><p>例如文章可能需要多次引用同一个链接，可以通过这种方式实现复用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"><span class="selector-tag">B</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[百度]</span>: https://baidu.com/ <span class="string">&quot;注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别&quot;</span></span><br></pre></td></tr></table></figure><p>效果：<br>A处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a><br>B处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>通过<code>![说明](图片地址)</code>来创建图片。其中图片地址支持url和本地图片路径。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[可能不存在的网络照片.jpeg]</span>(https://cdn.imalan.cn/img/post/<span class="number">2934349</span>b033b5bb5a19efc7233d3d539b700bcf5.jpg)</span><br><span class="line">!<span class="selector-attr">[rpc调用]</span>(../images/详解RPC协议/rpc调用流程.jpeg)</span><br></pre></td></tr></table></figure><p>效果：<br><img src="https://cdn.imalan.cn/img/post/2934349b033b5bb5a19efc7233d3d539b700bcf5.jpg" alt="可能不存在的网络照片.jpeg"></p><p><img src="/../images/%E8%AF%A6%E8%A7%A3RPC/rpc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpeg" alt="rpc调用"></p><blockquote><p>不同的 Markdown 应用程序在处理 URL 的方式可能存在不同，<strong>因此推荐使用编码后的url</strong>。例如如果添加的链接中有空格，为了兼容起见，最好使用 %20 （空格的编码形式）来代替空格。</p></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>通过<code>|</code>来设置表格，通过<code>---</code>来设置表头。其中，表头可以通过<code>:--:</code>来设置居中，<code>:--</code>来设置居左，<code>---:</code>来设置居右。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 姓名 | 年龄 | 性别 |</span><br><span class="line">| :--- | ---: | :--: |</span><br><span class="line">| 张三 | 18 | 男 |</span><br></pre></td></tr></table></figure><p>效果：</br></p><table><thead><tr><th align="left">姓名</th><th align="right">年龄</th><th align="center">性别</th></tr></thead><tbody><tr><td align="left">张三</td><td align="right">18</td><td align="center">男</td></tr></tbody></table><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>通过连续3个以上的相同符号：<code>*</code>、<code>-</code>、<code>_</code>来创建分割线。分割线的效果同样取决于使用的解析器。在实践中，最好在分隔线的前后均添加空白行。</br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">分割线1</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">分割线2</span></span><br><span class="line"><span class="string">___</span></span><br><span class="line"><span class="string">分割线3</span></span><br></pre></td></tr></table></figure><p>效果：</p><hr><p>分割线1</p><hr><p>分割线2</p><hr><p>分割线3</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开发经验】IDEA修改使用的JDK版本</title>
      <link href="/post/2052380.html"/>
      <url>/post/2052380.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在实际开发中偶尔会碰到需要切换JDK版本的情况，就我自己而言，大范围修改JDK版本有两次：</p><p>一次是由于我是21年开始使用MAC M1作为主力开发，当时Open JDK兼容性不太好，因此选择了zulu JDK。但不同JDK的实现有些差异，切换后可能会发现部分类丢失等情况导致编译异常。在Open JDK兼容M1版本后，果断将所有项目保持统一切换回Open JDK。</p><p>还有一次就是在开发的产品的JDK版本升级，公司要求所有产品都升级到JDK11以上，因此JDK8的老产品都进行了相关升级。</p><p>有时会记不清具体需要修改哪些地方导致遗漏，因此写这篇文章记录一下。</p><ol><li>修改项目编译使用的JDK版本<br>首先在主菜单IntelliJ IDEA&#x2F;preferences（windows版本对应全局settings界面）中，找到Build,Execution,Deployment -&gt; Compiler，修改编译使用的版本，然后Apply。</li></ol><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/1.png"></p><ol start="2"><li>添加项目JDK版本路径<br>如果是一个全新版本的JDK，那么需要在主菜单的File -&gt; Project Structure中，找到Project Settings -&gt; Platform Settings -&gt; SDKs中，添加JDK名称和对应路径。</li></ol><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/2.png"></p><ol start="3"><li>修改项目整体默认使用的JDK版本+路径<br>还是在Project Structure中，找到Project Settings -&gt; Project，修改JDK 和对应的language level。</li></ol><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/3.png"></p><ol start="4"><li>修改每个模块使用的JDK版本<br>这部分可以按需调整，比如某些模块使用JDK8，而其他模块使用JDK11。还是在Project Structure中，找到Project Settings -&gt; Modules，修改source中的JDK 和对应dependencies的language level。</li></ol><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/4.1.png"></p><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/4.2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA,JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开发经验】IDEA调式技巧</title>
      <link href="/post/f3b3a2f5.html"/>
      <url>/post/f3b3a2f5.html</url>
      
        <content type="html"><![CDATA[<h1 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h1><p>当我们需要数据一个新的服务代码，例如了解cassandra的启动流程，如果只看代码很容易遗漏一些细节，这个时候可以通过远程调试，一步步来跟踪代码，查看服务运行情况。</p><ol><li><p>调整debug configuration，添加远程debug参数<br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/1.jpg"><br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/2.jpg"><br>需要修改的参数：<br>①Host: 如果是本地启动的服务，可以填写localhost，否则填写服务ip<br>②Port: 调试端口，注意不要和服务器端的端口冲突。<br>另外注意公司可能做了端口拦截或防火墙，要保证本地服务是能访问到调试的ip+port。</p></li><li><p>在启动服务的入口添加参数<br>例如cassandra，是通过bin&#x2F;cassandra脚本，执行launch_server方法启动的。我们在脚本中将上面remote JVM参数添加到java启动命令中。其中需要将断点syspend改为y，否则不会在我们打的断点处停下来。<br> 完整命令类似于：</p> <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=trans<span class="keyword">port</span>=dt_socket,server=y,suspend=y,address=5005</span><br></pre></td></tr></table></figure><p>在脚本中修改后类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="variable">$NUMACTL</span> <span class="string">&quot;<span class="variable">$JAVA</span>&quot;</span> <span class="variable">$JVM_OPTS</span> -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y,address=5005 <span class="variable">$cassandra_parms</span> -<span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$CLASSPATH</span>&quot;</span> <span class="variable">$props</span> <span class="string">&quot;<span class="variable">$class</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>启动服务，等待debug连接<br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/3.jpg"><br>现在IDEA中点击debug按钮，监听远程服务断点，然后我们执行脚本启动服务，然后就可以在IDEA中调试服务了。</p></li><li><p>本地测试作为远程服务<br>当遇到一些集成测试，可能发生case间影响的时候，也可以尝试用这样的方法来调试。唯一不同的就是我们启动单测的方式：<br>对于mvn，可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean verify -Pjacoco -Dtest.env.runningMode=multi  -Dtest=&quot;&quot;  </span><br></pre></td></tr></table></figure><p>对于gradle，则可以执行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./gradlew</span> <span class="params">--info</span> :&#123;submodule&#125;<span class="function">:test</span> <span class="params">--tests=</span><span class="string">&quot;&quot;</span> -Dorg.gradle.debug=<span class="literal">true</span> <span class="params">--debug-jvm</span></span><br></pre></td></tr></table></figure><p>例如，单跑1个case：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --info :iot-tsdb-data-unit-test:test --tests=<span class="string">&quot;xxx.MysqlConnectorJTest&quot;</span> --debug-jvm</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="my-frequently-used-commands"><a href="#my-frequently-used-commands" class="headerlink" title="my frequently used commands"></a>my frequently used commands</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">&#x27;postname&#x27;</span></span><br><span class="line">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>hexo项目需要迁移&#x2F;换电脑时，直接将项目打包复制到新电脑上即可，node_modules部分文件可能由于网络下载会被拦截，<br>mac可在隐私与安全中选择不拦截即可正常使用</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
