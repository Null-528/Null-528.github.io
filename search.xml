<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【DevOps】集群日志收集</title>
      <link href="/post/73d80bc6.html"/>
      <url>/post/73d80bc6.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在实际集群部署中，遇到很多异常都需要根据日志进一步进行定位，但是假如是 k8s 这类容器部署，在服务发生异常时（尤其是因为容器所在机器发生了异常），可能会自动重启、调度到其他机器上去，从而导致异常现场的日志发生丢失，因此我们需要将日志持久化到磁盘上。</p><p>当然这种情况下将容器日志路径挂载到实际物理机磁盘下上也是一个解决方案，但是考虑到大集群情况下，比如集群有10个、20个物理节点，我们搜索某个信息时需要遍历所有物理机非常麻烦，因此最好还是通过一个统一的日志采集系统来进行日志的收集，方便对日志内容的检索和统计。</p><h1 id="ELKB-Elasticsearch-Logstash-Kibana-Beats"><a href="#ELKB-Elasticsearch-Logstash-Kibana-Beats" class="headerlink" title="ELKB (Elasticsearch + Logstash + Kibana + Beats)"></a>ELKB (Elasticsearch + Logstash + Kibana + Beats)</h1><p>整体架构及组件功能：<br><img src="/../images/%E9%9B%86%E7%BE%A4%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/ELKB.png"></p><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install elastic/tap/elasticsearch-full</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/homebrew/etc/elasticsearch/elasticsearch.yml</span><br></pre></td></tr></table></figure><p>主要配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/opt/homebrew/var/lib/elasticsearch</span> <span class="comment"># 数据存储路径</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/opt/homebrew/var/log/elasticsearch</span> <span class="comment"># 日志存储路径</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="string">localhost</span> <span class="comment"># 集群内节点间通信的IP，这里用的是宿主机的IP</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span> <span class="comment"># Elasticsearch 服务端口，默认9200</span></span><br><span class="line"><span class="attr">xpack.ml.enabled:</span> <span class="literal">false</span> <span class="comment"># 禁用机器学习功能，否则会占用大量内存，并且有些操作系统如 macOS可能会缺失一些特定系统库</span></span><br></pre></td></tr></table></figure><p>增加 jdk 配置，不同 elasticsearch 版本 JDK 可能不同，默认jdk 路径是&#x2F;opt&#x2F;homebrew&#x2F;Cellar&#x2F;elasticsearch-full&#x2F;7.17.4&#x2F;libexec&#x2F;jdk.app&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java，可能启动后会在日志中会报错找不到文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/homebrew/Cellar/elasticsearch-full/7.17.4/bin/elasticsearch</span><br></pre></td></tr></table></figure><p>增加配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ES_JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ES_JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$ES_JAVA_HOME</span>/lib/dt.jar:<span class="variable">$ES_JAVA_HOME</span>/lib/tool.jar</span><br></pre></td></tr></table></figure><p>ES 服务默认会占用系统一半以上的内存，我们本地测试时需要修改 jvm 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/homebrew/etc/elasticsearch/jvm.options</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms4g</span><br><span class="line">-Xmx4g</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start elastic/tap/elasticsearch-full</span><br></pre></td></tr></table></figure><p>运行后验证，使用浏览器访问：<a href="http://localhost:9200/">http://localhost:9200/</a> ，即可出现响应，类似：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;MacBook-Pro-2.local&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;elasticsearch&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;EkOmQh-OQwmM0fCHiJs6Zg&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;7.17.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;tar&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;79878662c54c886ae89206c685d9f1051a9d6411&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;2022-05-18T18:04:20.964345128Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;8.11.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h2><p>Kibana 用于可视化 Elasticsearch 中的数据，以及可视化查询结果。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install elastic/tap/kibana-full</span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/homebrew/etc/kibana/kibana.yml</span><br></pre></td></tr></table></figure><p>主要配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span> <span class="comment"># 设置语言为中文</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;localhost&quot;</span> <span class="comment"># Kibana 服务监听的IP，默认是 localhost</span></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span> <span class="comment"># Kibana 服务端口，默认是5601</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>] <span class="comment"># Elasticsearch 服务的地址，按照之前的配置使用 localhost:9200</span></span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start elastic/tap/kibana-full</span><br></pre></td></tr></table></figure><p>使用浏览器访问：<a href="http://localhost:5601/">http://localhost:5601/</a> ，即可出现响应。</p><h2 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install elastic/tap/logstash-full</span><br></pre></td></tr></table></figure><p>如果安装报错：Error: elastic&#x2F;tap&#x2F;logstash-full: undefined method plist_options’ for class Formulary::FormulaNamespace814558d06945ccd61916b06a6b5d66dce132f220d51bc0fd776438ac3417f792::LogstashFull<br>解决办法：<br>尝试手动修改该配方以移除对 plist_options 的引用:</p><ol><li>找到 logstash-full 配方文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew edit elastic/tap/logstash-full</span><br></pre></td></tr></table></figure></li><li>在配方文件中，找到 plist_options 的引用并将其删除:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plist_options :manual =&gt; <span class="string">&quot;logstash&quot;</span></span><br></pre></td></tr></table></figure></li><li>保存并关闭编辑器，重新安装logstash</li></ol><h3 id="配置与启动"><a href="#配置与启动" class="headerlink" title="配置与启动"></a>配置与启动</h3><p>增加 jdk 配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/homebrew/Cellar/logstash-full/7.17.4/bin/logstash</span><br></pre></td></tr></table></figure><p>增加配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LS_JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$LS_JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$LS_JAVA_HOME</span>/lib/dt.jar:<span class="variable">$LS_JAVA_HOME</span>/lib/tool.jar</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/homebrew/etc/logstash/logstash.yml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api.http.host: 127.0.0.1 <span class="comment"># 配置logstash服务监听的IP，默认是 localhost。分布式架构中一定要配置为 logstash 主机 ip，不然无法远程访问</span></span><br><span class="line">api.http.port: 9600-9700 <span class="comment"># Logstash 服务端口范围</span></span><br><span class="line">path.data: <span class="comment"># 配置数据存储路径，默认是 LOGSTASH_HOME/data</span></span><br><span class="line">path.logs:/opt/homebrew/var/log/logstash <span class="comment"># 配置日志存储路径，默认是 LOGSTASH_HOME/logs</span></span><br></pre></td></tr></table></figure><p>logstash 进程不用预先启动，使用时启动即可。</p><h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><p>使用标准输入输出测试logstash服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/homebrew/Cellar/logstash-full/7.17.4/bin/logstash -e <span class="string">&#x27;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123; &#125; &#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>输入hello，可以看到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;@timestamp&quot;</span> =&gt; <span class="number">2025</span><span class="number">-01</span><span class="number">-14</span>T14<span class="punctuation">:</span><span class="number">39</span><span class="punctuation">:</span><span class="number">37.668</span>Z<span class="punctuation">,</span></span><br><span class="line">       <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;MacBook-Pro-2.local&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用标准输入 logstash 服务，将输出传输给 elasticsearch：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/homebrew/Cellar/logstash-full/7.17.4/bin/logstash -e <span class="string">&#x27;input &#123; stdin &#123; &#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; [&quot;localhost:9200&quot;] index =&gt; &quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot; &#125; &#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>输入 hello，可以在 kibana 中看到数据：进入 localhost:9200，侧边栏中，Stack Management -&gt; 索引管理，即可看到已经新增了logstash-2025.01.14索引：<br><img src="/../images/%E9%9B%86%E7%BE%A4%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/kibana%20%E6%96%B0%E7%B4%A2%E5%BC%95.png"></p><h2 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h2><p>Beats 是轻量级的数据采集器并且可以自定义采集规则。它可以安装在每个节点上，收集日志并将其发送到 Logstash 或直接存储在 Elasticsearch 中。 Beats 主要是用来分担原本 Logstash 的压力。</p><h2 id="其他中间件"><a href="#其他中间件" class="headerlink" title="其他中间件"></a>其他中间件</h2><h1 id="EFK-Elasticsearch、Fluentd、Kibana"><a href="#EFK-Elasticsearch、Fluentd、Kibana" class="headerlink" title="EFK (Elasticsearch、Fluentd、Kibana)"></a>EFK (Elasticsearch、Fluentd、Kibana)</h1>]]></content>
      
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分布式协议】Raft 和 Gossip 协议</title>
      <link href="/post/22fe303b.html"/>
      <url>/post/22fe303b.html</url>
      
        <content type="html"><![CDATA[<p>为避免单点故障，部分服务通过分布式来提高系统稳定性，由此出现了数据一致性的需求。一致性有强一致性和弱一致性（最终一致性）：</p><ul><li>强一致性：数据一旦更新，所有节点上的数据都是同步的，例如 Paxos、Raft[1]、ZAB 协议等。</li><li>弱一致性：数据更新后，不同节点上的数据可能不一致，但最终会达到一致的状态，例如 Gossip 协议。</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见的分布式数据库使用的分布式协议：</span><br><span class="line"><span class="bullet">1.</span> Raft：excd、HBase、MongoDB</span><br><span class="line"><span class="bullet">2.</span> ZAB：Zookeeper</span><br><span class="line"><span class="bullet">3.</span> Paxos：Chubby、Riak</span><br><span class="line"><span class="bullet">4.</span> Gossip：Cassandra、Dynamo</span><br></pre></td></tr></table></figure><p>这一章节分别讨论强一致和弱一致的各自一种代表协议： Raft 和 Gossip。</p><h1 id="1-概念对比"><a href="#1-概念对比" class="headerlink" title="1. 概念对比"></a>1. 概念对比</h1><h2 id="1-1-Raft中的关键概念"><a href="#1-1-Raft中的关键概念" class="headerlink" title="1.1 Raft中的关键概念"></a>1.1 Raft中的关键概念</h2><p>Raft 是一种为分布式系统设计的一致性算法，用于确保多个节点之间的数据达成一致。以下是 Raft 中的一些关键概念：</p><h3 id="角色："><a href="#角色：" class="headerlink" title="角色："></a>角色：</h3><ul><li>Leader（领导者）： Raft 中的一个节点被选为领导者，负责处理客户端请求和管理日志的复制。领导者周期性地发送心跳以保持其领导地位。</li><li>Follower（跟随者）： 其他节点是跟随者，它们 passively 处理领导者的请求。如果一个跟随者在一定时间内没有收到领导者的心跳，它可能会发起领导者选举。</li><li>Candidate（候选人）： 当一个节点希望成为领导者时，它首先成为候选人，并请求其他节点投票。</li></ul><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul><li>领导者选举（Leader Election）： Raft 使用随机化的选举超时来触发领导者选举。节点在等待随机时间后成为候选人，请求其他节点的投票。如果一个候选人收到大多数节点的投票，它将成为新的领导者。</li><li>日志复制（Log Replication）： 领导者负责将客户端的请求附加到其日志中，并通过心跳将日志条目复制到跟随者。只有被大多数节点确认的日志条目才被认为是已提交的。</li><li>心跳（Heartbeat）： 领导者通过周期性的心跳消息向跟随者表明其活跃状态。如果一个跟随者在一定时间内没有收到心跳，它可能认为领导者失效并触发领导者选举。</li><li>选举超时（Election Timeout）： 用于触发领导者选举的随机化超时机制。节点在等待一个随机的选举超时后成为候选人。</li><li>保持一致性（Maintaining Consistency）： Raft 通过使用投票和多数确认来确保数据一致性。只有在大多数节点都同意的情况下，领导者的日志才会被认为是已提交的。</li><li>集群成员变更： Raft 允许动态地添加或删除节点。节点加入或离开集群时，Raft 使用一种叫做集群成员变更的机制来保持一致性。</li><li>复制状态机（Replicated State Machine）： Raft 通过复制状态机的方式来实现一致性。每个节点上都有一个状态机，领导者通过复制日志条目来更新状态机的状态。</li></ul><p>这些概念共同确保了 Raft 算法在分布式系统中的可靠运行，提供了一致性和容错性。 Raft 的设计目标是易于理解和实现，以提高分布式系统的可维护性。</p><h1 id="1-2-Gossip中的关键概念"><a href="#1-2-Gossip中的关键概念" class="headerlink" title="1.2 Gossip中的关键概念"></a>1.2 Gossip中的关键概念</h1><p>Gossip 是一种去中心化的通信协议，用于在分布式系统中传播信息。以下是 Gossip 中的一些关键概念：</p><h3 id="角色：-1"><a href="#角色：-1" class="headerlink" title="角色："></a>角色：</h3><ul><li>节点（Nodes）： 分布式系统中的独立单元。每个节点都有一个状态，可能是需要在整个系统中传播的信息。</li><li>种子节点（Seed）： 种子节点可以是系统中的任意节点，它负责发起信息传播过程。</li></ul><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ul><li>信息传播（Information Propagation）： Gossip 协议的核心目标是通过节点之间的随机通信来传播信息。节点定期与其他节点随机选择的邻居通信，交换状态信息。</li><li>去中心化通信（Decentralized Communication）： Gossip 不依赖于中心化的结构。节点之间的通信是去中心化的，每个节点可以直接与其他节点通信，而无需通过中心协调者。</li><li>状态信息（State Information）： 每个节点都包含一些状态信息，这些信息需要在整个系统中传播。这可能包括节点的健康状态、负载情况等。</li><li>信息随机传播（Randomized Information Propagation）： Gossip 使用随机选择的邻居节点进行信息传播。这种随机性有助于确保整个系统中的信息快速传播。</li><li>信息更新（Information Update）： 当节点与其他节点通信时，它们可能会交换状态信息并更新自己的状态。这确保了系统中的信息保持最新。</li><li>最终一致性（Eventual Consistency）： Gossip 的设计目标之一是实现最终一致性。虽然在某个时间点不同节点之间的状态可能不同，但随着时间的推移，系统中的状态将趋于一致。</li><li>容错性（Fault Tolerance）： Gossip 具有一定的容错性。即使某些节点失效，信息仍然可以通过其他路径传播，从而提高系统的健壮性。</li><li>可扩展性（Scalability）： 由于通信是去中心化的，Gossip 具有良好的可扩展性。随着节点的增加，系统的整体性能不会线性下降。</li><li>定期通信（Periodic Communication）： 节点之间的通信是定期进行的。每个节点定期选择邻居节点进行信息交换。</li></ul><p>Gossip 协议的灵活性和去中心化特性使其成为某些分布式系统中有效的通信机制。节点之间的信息传播通过简单、分散和随机的方式进行，从而提高了系统的可扩展性和容错性。</p><h1 id="2-信息传播对比"><a href="#2-信息传播对比" class="headerlink" title="2. 信息传播对比"></a>2. 信息传播对比</h1><h2 id="2-1-Raft信息传播"><a href="#2-1-Raft信息传播" class="headerlink" title="2.1 Raft信息传播"></a>2.1 Raft信息传播</h2><p>Raft是一种分布式一致性算法，它通过选举和日志复制来保证分布式系统中的数据一致性。在Raft中，信息传播的过程如下：</p><ul><li>领导人选举： 在Raft中，每个节点都可以成为领导人，但是只有一个领导人可以同时存在。领导人选举的过程包括选举超时时间、候选人选举和领导人选举等步骤。</li><li>日志复制： 当领导人被选举出来后，它会将日志条目复制到其他节点上。领导人会向其他节点发送心跳消息，以确保其他节点的日志条目与领导人的日志条目保持一致。</li><li>日志条目的提交： 当领导人收到大多数节点的确认消息后，它会将日志条目提交到系统中。提交的日志条目会被应用到状态机中，从而保证数据的一致性。</li><li>日志条目的应用： 当日志条目被提交后，领导人会将其应用到状态机中，并将结果返回给客户端。</li><li>日志条目的复制： 当其他节点收到领导人发送的日志条目时，它们会将日志条目复制到自己的日志中，并向领导人发送确认消息。</li></ul><p>以上就是Raft中信息传播的基本过程。需要注意的是，Raft中的信息传播过程是基于RPC的，因此需要考虑网络延迟、网络分区等因素的影响。</p><h2 id="2-2-Gossip信息传播"><a href="#2-2-Gossip信息传播" class="headerlink" title="2.2 Gossip信息传播"></a>2.2 Gossip信息传播</h2><p>Gossip协议是一种基于点对点通信的分布式信息传播协议，通过随机化的节点选择和信息交换来实现高效的信息传递。在Gossip协议中，信息传播的过程如下：</p><ul><li>种子节点周期性地散播消息： 种子节点可以是系统中的任意节点，它负责发起信息传播过程。</li><li>被感染节点随机选择N个邻接节点散播消息： 被感染节点是指已经接收到消息的节点，它会将消息继续传播给其他节点。邻接节点是指与被感染节点直接相连的节点。</li><li>节点只接收消息不反馈结果： 在Gossip协议中，节点之间没有明确的反馈机制，节点只知道它已经接收到消息，但不知道其他节点是否已经接收到消息。</li><li>每次散播消息都选择尚未发送过的节点进行散播： 这样可以避免消息的重复传播，提高信息传播的效率。</li><li>收到消息的节点不再往发送节点散播： 这样可以减少消息的循环传播，降低网络开销。</li><li>以上就是Gossip协议中信息传播的基本过程。需要注意的是，Gossip协议的信息传播过程是随机化的，因此信息传播的速度和范围可能会受到网络拓扑结构、节点数量等因素的影响。</li></ul><h1 id="3-优缺点对比"><a href="#3-优缺点对比" class="headerlink" title="3. 优缺点对比"></a>3. 优缺点对比</h1><p>Raft和Gossip是两种在分布式系统中广泛应用的协议，它们各自具有不同的优点和缺点。</p><h2 id="3-1-Raft优缺点"><a href="#3-1-Raft优缺点" class="headerlink" title="3.1 Raft优缺点"></a>3.1 Raft优缺点</h2><p>Raft的优点：</p><ul><li>保证强一致性：Raft协议通过一系列机制，如领导者选举和日志复制，确保分布式系统中的数据一致性。</li><li>数据安全性高：Raft协议提供了数据的安全性和可靠性保证，通过日志复制和持久化机制减少了数据丢失的风险。</li><li>易于理解和实现：Raft协议相对简单，易于理解和实现，降低了开发和维护的成本。</li></ul><p>Raft的缺点：</p><ul><li>性能开销大：Raft协议需要维护领导者选举和日志复制等机制，相对于其他一些简单的分布式协议，其性能开销可能较大。</li><li>实现复杂度较高：Raft协议相对复杂，需要开发人员具备一定的分布式系统知识和经验，增加了开发和维护的难度（比较容易出现 bug）。</li></ul><h2 id="3-2-Gossip优缺点"><a href="#3-2-Gossip优缺点" class="headerlink" title="3.2 Gossip优缺点"></a>3.2 Gossip优缺点</h2><p>Gossip的优点：</p><ul><li>简单易实现：Gossip协议相对简单，易于实现和维护，降低了开发成本。</li><li>灵活性高：Gossip协议适用于各种分布式系统，可以根据实际需求进行定制和扩展。<br> -动态适应性强：Gossip协议能够动态适应系统的变化，如节点的增减和网络分区等。</li></ul><p>Gossip的缺点：</p><ul><li>数据一致性难以保证：Gossip协议不保证数据的一致性，需要结合其他机制来确保数据的一致性。</li><li>数据安全性相对较低：由于Gossip协议的数据复制是随机的，因此相对于Raft协议，其数据安全性可能较低。</li><li>性能开销较大：Gossip协议需要进行大量的信息广播和传播，相对于Raft协议，其性能开销可能较大。</li></ul><p>总的来说，Raft和Gossip各有优缺点，选择使用哪种协议需要根据实际需求进行权衡。在需要强一致性和高安全性的场景中，Raft协议是更好的选择；而在需要简单实现、高灵活性和动态适应性的场景中，Gossip协议可能更加适合。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><table><thead><tr><th align="left">对比事项</th><th align="left">Raft</th><th align="left">Gossip</th></tr></thead><tbody><tr><td align="left">数据一致性</td><td align="left">Raft 协议通过选举和日志复制机制确保强一致性。</td><td align="left">Gossip 协议不保证数据一致性，主要用于信息传播。</td></tr><tr><td align="left">领导者选举</td><td align="left">Raft 中的领导者选举是核心机制，通过过半数投票产生领导者。</td><td align="left">Gossip 没有领导者选举的概念，信息传播是随机的。</td></tr><tr><td align="left">数据复制</td><td align="left">Raft 通过日志复制机制确保数据安全性和一致性。</td><td align="left">Gossip 没有数据复制机制，仅用于信息传播。</td></tr><tr><td align="left">可用性</td><td align="left">Raft 适用于需要可靠数据一致性的分布式系统，如分布式文件系统、数据库等。</td><td align="left">Gossip 适用于去中心化的分布式系统，如 P2P 网络、信息传播应用等。</td></tr><tr><td align="left">灵活性</td><td align="left">Raft 相对复杂，实现和维护成本较高。</td><td align="left">Gossip 相对简单，易于实现和部署。</td></tr></tbody></table><p>在选择 Raft 和 Gossip 协议时，需要根据实际需求进行权衡。Raft 更适合需要强一致性和可靠数据复制的场景，如分布式文件系统和数据库等。而 Gossip 则适合需要快速信息传播和去中心化系统的场景，如 P2P 网络和信息传播应用等。    </p><p>[1] 论文：In Search of an Understandable Consensus Algorithm (<a href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a>)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据库】时序数据库</title>
      <link href="/post/49a4663b.html"/>
      <url>/post/49a4663b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、时序数据库列表"><a href="#一、时序数据库列表" class="headerlink" title="一、时序数据库列表"></a>一、时序数据库列表</h1><h2 id="1-1-开源列表"><a href="#1-1-开源列表" class="headerlink" title="1.1 开源列表"></a>1.1 开源列表</h2><table><thead><tr><th align="left">name</th><th align="left">github</th><th align="center">status</th><th align="left">lang</th><th align="left">kind</th><th align="center">backend</th><th align="center">protocol</th><th align="center">query</th><th align="center">license</th></tr></thead><tbody><tr><td align="left">Akumuli</td><td align="left"><a href="https://github.com/akumuli/Akumuli">https://github.com/akumuli/Akumuli</a></td><td align="center">maintained</td><td align="left">c++</td><td align="left"></td><td align="center">localfs</td><td align="center">tcp</td><td align="center">text</td><td align="center">apache-2.0</td></tr><tr><td align="left">Arctic</td><td align="left"><a href="https://github.com/man-group/arctic">https://github.com/man-group/arctic</a></td><td align="center">active</td><td align="left">python</td><td align="left"></td><td align="center">mongodb</td><td align="center">tcp</td><td align="center">python</td><td align="center">lgpl</td></tr><tr><td align="left">Argus</td><td align="left"><a href="https://github.com/salesforce/Argus">https://github.com/salesforce/Argus</a></td><td align="center">dead</td><td align="left">java</td><td align="left"></td><td align="center">hbase</td><td align="center">http</td><td align="center">json</td><td align="center">bsd</td></tr><tr><td align="left">Atlas</td><td align="left"><a href="https://github.com/Netflix/atlas">https://github.com/Netflix/atlas</a></td><td align="center">maintained</td><td align="left">scala</td><td align="left"></td><td align="center">memory</td><td align="center">http</td><td align="center">stack</td><td align="center">apache-2.0</td></tr><tr><td align="left">Beringei</td><td align="left"><a href="https://github.com/facebookarchive/beringei">https://github.com/facebookarchive/beringei</a></td><td align="center">dead</td><td align="left">c++</td><td align="left"></td><td align="center">memory</td><td align="center">thrift</td><td align="center">thrift</td><td align="center">bsd</td></tr><tr><td align="left">BigGraphite</td><td align="left"><a href="https://github.com/criteo/biggraphite">https://github.com/criteo/biggraphite</a></td><td align="center">maintained</td><td align="left">python</td><td align="left"></td><td align="center">cassandra</td><td align="center">http</td><td align="center">graphite</td><td align="center">apache-2.0</td></tr><tr><td align="left">Blueflood</td><td align="left"><a href="https://github.com/rackerlabs/blueflood">https://github.com/rackerlabs/blueflood</a></td><td align="center">dead</td><td align="left">java</td><td align="left"></td><td align="center">cassandra,elasticsearch</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">BTrDB</td><td align="left"><a href="https://github.com/BTrDB/btrdb-server">https://github.com/BTrDB/btrdb-server</a></td><td align="center">maintained</td><td align="left">go</td><td align="left"></td><td align="center">ceph</td><td align="center">http</td><td align="center">json</td><td align="center">gpl</td></tr><tr><td align="left">Catena</td><td align="left"><a href="https://github.com/Cistern/catena">https://github.com/Cistern/catena</a></td><td align="center">dead</td><td align="left">go</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">json</td><td align="center">bsd</td></tr><tr><td align="left">Chronix</td><td align="left"><a href="https://github.com/ChronixDB/chronix.server">https://github.com/ChronixDB/chronix.server</a></td><td align="center">maintained</td><td align="left">java</td><td align="left"></td><td align="center">solr</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">Citus</td><td align="left"><a href="https://github.com/citusdata/citus">https://github.com/citusdata/citus</a></td><td align="center">active</td><td align="left">c</td><td align="left"></td><td align="center">postgresql</td><td align="center">tcp</td><td align="center">sql</td><td align="center">agpl-3.0</td></tr><tr><td align="left">ClickHouse</td><td align="left"><a href="https://github.com/ClickHouse/ClickHouse">https://github.com/ClickHouse/ClickHouse</a></td><td align="center">active</td><td align="left">c++</td><td align="left">OLAP(Column-Oriented)</td><td align="center">localfs</td><td align="center">tcp</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Cortex</td><td align="left"><a href="https://github.com/cortexproject/cortex">https://github.com/cortexproject/cortex</a></td><td align="center">active</td><td align="left">go</td><td align="left">Prometheus-Oriented</td><td align="center">s3,cassandra,bigtable,dynamodb</td><td align="center">http</td><td align="center">promql</td><td align="center">apache-2.0</td></tr><tr><td align="left">CrateDB</td><td align="left"><a href="https://github.com/crate/crate">https://github.com/crate/crate</a></td><td align="center">active</td><td align="left">java</td><td align="left"></td><td align="center">lucene,s3,elasticsearch</td><td align="center">http</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">DalmatinerDB</td><td align="left"><a href="https://github.com/dalmatinerdb/dalmatinerdb">https://github.com/dalmatinerdb/dalmatinerdb</a></td><td align="center">maintained</td><td align="left">erlang</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">text</td><td align="center">mit</td></tr><tr><td align="left">FiloDB</td><td align="left"><a href="https://github.com/filodb/FiloDB">https://github.com/filodb/FiloDB</a></td><td align="center">active</td><td align="left">scala</td><td align="left"></td><td align="center">cassandra</td><td align="center">http</td><td align="center">promql,metricsql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Flint</td><td align="left"><a href="https://github.com/twosigma/flint">https://github.com/twosigma/flint</a></td><td align="center">maintained</td><td align="left">scala</td><td align="left"></td><td align="center">spark</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">Gnocchi</td><td align="left"><a href="https://github.com/gnocchixyz/gnocchi">https://github.com/gnocchixyz/gnocchi</a></td><td align="center">dead</td><td align="left">python</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">GridDB</td><td align="left"><a href="https://github.com/griddb/griddb">https://github.com/griddb/griddb</a></td><td align="center">active</td><td align="left">c++</td><td align="left"></td><td align="center">localfs</td><td align="center">jdbc</td><td align="center">sql,tql</td><td align="center">apache-2.0</td></tr><tr><td align="left">HawkularMertics</td><td align="left"><a href="https://github.com/hawkular/hawkular-metrics">https://github.com/hawkular/hawkular-metrics</a></td><td align="center">maintained</td><td align="left">java</td><td align="left"></td><td align="center">cassandra</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">Heroic</td><td align="left"><a href="https://github.com/spotify/heroic">https://github.com/spotify/heroic</a></td><td align="center">maintained</td><td align="left">java</td><td align="left"></td><td align="center">bigtable,cassandra,elasticsearch</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">InfluxDB</td><td align="left"><a href="https://github.com/influxdata/influxdb">https://github.com/influxdata/influxdb</a></td><td align="center">active</td><td align="left">go</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">influxql,flux</td><td align="center">mit</td></tr><tr><td align="left">IoTDB</td><td align="left"><a href="https://github.com/apache/incubator-iotdb">https://github.com/apache/incubator-iotdb</a></td><td align="center">active</td><td align="left">java</td><td align="left"></td><td align="center">hdfs,localfs</td><td align="center">tcp</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">IRONdb</td><td align="left"><a href="https://www.circonus.com/solutions/time-series-database/">https://www.circonus.com/solutions/time-series-database/</a></td><td align="center">active</td><td align="left">c</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">json</td><td align="center">proprietary</td></tr><tr><td align="left">KairosDB</td><td align="left"><a href="https://github.com/kairosdb/kairosdb">https://github.com/kairosdb/kairosdb</a></td><td align="center">maintained</td><td align="left">java</td><td align="left"></td><td align="center">cassandra</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">Khronus</td><td align="left"><a href="https://github.com/khronus/khronus">https://github.com/khronus/khronus</a></td><td align="center">dead</td><td align="left">scala</td><td align="left"></td><td align="center">cassandra</td><td align="center">http</td><td align="center">json,influxql</td><td align="center">apache-2.0</td></tr><tr><td align="left">LinDB</td><td align="left"><a href="https://github.com/lindb/lindb">https://github.com/lindb/lindb</a></td><td align="center">active</td><td align="left">go</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">M3</td><td align="left"><a href="https://github.com/m3db">https://github.com/m3db</a></td><td align="center">active</td><td align="left">go</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">promql,graphite,m3query,sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Metrictank</td><td align="left"><a href="https://github.com/grafana/metrictank">https://github.com/grafana/metrictank</a></td><td align="center">active</td><td align="left">go</td><td align="left"></td><td align="center">cassandra,elasticsearch</td><td align="center">http</td><td align="center">graphite</td><td align="center">agpl-3.0</td></tr><tr><td align="left">Newts</td><td align="left"><a href="https://github.com/OpenNMS/newts/">https://github.com/OpenNMS/newts/</a></td><td align="center">maintained</td><td align="left">java</td><td align="left"></td><td align="center">cassandra</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">OpenTSDB</td><td align="left"><a href="https://github.com/OpenTSDB/opentsdb">https://github.com/OpenTSDB/opentsdb</a></td><td align="center">maintained</td><td align="left">java</td><td align="left"></td><td align="center">hbase</td><td align="center">http,tcp</td><td align="center">json</td><td align="center">lgpl</td></tr><tr><td align="left">Apache Pinot</td><td align="left"><a href="https://github.com/apache/incubator-pinot">https://github.com/apache/incubator-pinot</a></td><td align="center">active</td><td align="left">java</td><td align="left"></td><td align="center">s3,hdfs,azdls</td><td align="center">http</td><td align="center">pql</td><td align="center">apache-2.0</td></tr><tr><td align="left">PinusDB</td><td align="left"><a href="https://github.com/pinusdb/pinusdb">https://github.com/pinusdb/pinusdb</a></td><td align="center">maintained</td><td align="left">c++</td><td align="left"></td><td align="center">localfs</td><td align="center">tcp</td><td align="center">sql</td><td align="center">gpl-3.0</td></tr><tr><td align="left">PipelineDB</td><td align="left"><a href="https://github.com/pipelinedb/pipelinedb">https://github.com/pipelinedb/pipelinedb</a></td><td align="center">dead</td><td align="left">c</td><td align="left"></td><td align="center">postgresql</td><td align="center">tcp</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Prometheus</td><td align="left"><a href="https://github.com/prometheus/prometheus">https://github.com/prometheus/prometheus</a></td><td align="center">active</td><td align="left">go</td><td align="left"></td><td align="center">localfs</td><td align="center">prometheus</td><td align="center">promql</td><td align="center">apache-2.0</td></tr><tr><td align="left">QuestDB</td><td align="left"><a href="https://github.com/questdb/questdb">https://github.com/questdb/questdb</a></td><td align="center">active</td><td align="left">java</td><td align="left"></td><td align="center">localfs</td><td align="center">postgresql</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Seriously</td><td align="left"><a href="https://github.com/dustin/seriesly">https://github.com/dustin/seriesly</a></td><td align="center">dead</td><td align="left">go</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">json</td><td align="center">mit</td></tr><tr><td align="left">Sidewinder</td><td align="left"><a href="https://github.com/srotya/sidewinder">https://github.com/srotya/sidewinder</a></td><td align="center">dead</td><td align="left">java</td><td align="left"></td><td align="center">localfs</td><td align="center">tcp</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">SiriDB</td><td align="left"><a href="https://github.com/SiriDB/siridb-server">https://github.com/SiriDB/siridb-server</a></td><td align="center">active</td><td align="left">c</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">text</td><td align="center">mit</td></tr><tr><td align="left">TDengine</td><td align="left"><a href="https://github.com/taosdata/TDengine">https://github.com/taosdata/TDengine</a></td><td align="center">active</td><td align="left">c</td><td align="left"></td><td align="center">localfs</td><td align="center">tcp</td><td align="center">sql</td><td align="center">agpl-3.0</td></tr><tr><td align="left">Tgres</td><td align="left"><a href="https://github.com/tgres/tgres">https://github.com/tgres/tgres</a></td><td align="center">dead</td><td align="left">go</td><td align="left"></td><td align="center">postgresql</td><td align="center">tcp</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Thanos</td><td align="left"><a href="https://github.com/thanos-io/thanos">https://github.com/thanos-io/thanos</a></td><td align="center">active</td><td align="left">go</td><td align="left"></td><td align="center">localfs,s3</td><td align="center">http,grpc</td><td align="center">promql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Timebala</td><td align="left"><a href="https://github.com/mattbostock/timbala">https://github.com/mattbostock/timbala</a></td><td align="center">dead</td><td align="left">go</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">promql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Timely</td><td align="left"><a href="https://github.com/NationalSecurityAgency/timely">https://github.com/NationalSecurityAgency/timely</a></td><td align="center">maintained</td><td align="left">java</td><td align="left"></td><td align="center">hdfs,accumulo</td><td align="center">http</td><td align="center">json</td><td align="center">apache-2.0</td></tr><tr><td align="left">TimescaleDB</td><td align="left"><a href="https://github.com/timescale/timescaledb">https://github.com/timescale/timescaledb</a></td><td align="center">active</td><td align="left">c</td><td align="left"></td><td align="center">postgresql</td><td align="center">postgres</td><td align="center">sql</td><td align="center">apache-2.0</td></tr><tr><td align="left">TrailDB</td><td align="left"><a href="https://github.com/traildb/traildb">https://github.com/traildb/traildb</a></td><td align="center">dead</td><td align="left">c</td><td align="left"></td><td align="center">localfs</td><td align="center">embed</td><td align="center">python</td><td align="center">mit</td></tr><tr><td align="left">tsdb-layer</td><td align="left"><a href="https://github.com/richardartoul/tsdb-layer">https://github.com/richardartoul/tsdb-layer</a></td><td align="center">dead</td><td align="left">go</td><td align="left"></td><td align="center">foundationdb</td><td align="center">grpc</td><td align="center">text</td><td align="center">unknown</td></tr><tr><td align="left">μts</td><td align="left"><a href="https://github.com/mixer/uts">https://github.com/mixer/uts</a></td><td align="center">dead</td><td align="left">javascript</td><td align="left"></td><td align="center">memory</td><td align="center">embed</td><td align="center">json</td><td align="center">mit</td></tr><tr><td align="left">Vaultaire</td><td align="left"><a href="https://github.com/afcowie/vaultaire">https://github.com/afcowie/vaultaire</a></td><td align="center">dead</td><td align="left">haskell</td><td align="left"></td><td align="center">ceph</td><td align="center">http</td><td align="center">json</td><td align="center">unknown</td></tr><tr><td align="left">VictoriaMetrics</td><td align="left"><a href="https://github.com/VictoriaMetrics/VictoriaMetrics">https://github.com/VictoriaMetrics/VictoriaMetrics</a></td><td align="center">active</td><td align="left">go</td><td align="left"></td><td align="center">localfs</td><td align="center">http</td><td align="center">promql,metricsql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Vulcan</td><td align="left"><a href="https://github.com/digitalocean/vulcan">https://github.com/digitalocean/vulcan</a></td><td align="center">dead</td><td align="left">go</td><td align="left"></td><td align="center">cassandra</td><td align="center">http</td><td align="center">promql</td><td align="center">apache-2.0</td></tr><tr><td align="left">Warp10</td><td align="left"><a href="https://github.com/senx/warp10-platform">https://github.com/senx/warp10-platform</a></td><td align="center">active</td><td align="left">java</td><td align="left"></td><td align="center">leveldb,hbase</td><td align="center">http</td><td align="center">warpscript</td><td align="center">apache-2.0</td></tr><tr><td align="left">Xephon-K</td><td align="left"><a href="https://github.com/xephonhq/xephon-k">https://github.com/xephonhq/xephon-k</a></td><td align="center">dead</td><td align="left">go</td><td align="left"></td><td align="center">cassandra,localfs</td><td align="center">http,grpc</td><td align="center">json</td><td align="center">mit</td></tr></tbody></table><h3 id="开源协议对比"><a href="#开源协议对比" class="headerlink" title="开源协议对比"></a>开源协议对比</h3><ol><li><p>BSD开源协议（original BSD license、FreeBSD license、Original BSD license）<br>商业应用友好，但当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库&#x2F;软件，则需要在类库&#x2F;软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者&#x2F;机构名字和原来产品的名字做市场推广。</li></ul></li><li><p>Apache-2.0（Apache License, Version 2.0、Apache License, Version 1.1、Apache License, Version 1.0）<br>商业应用友好，类似 BSD 同样鼓励代码共享和尊重原作者的著作权，同样允许作为开源或商业软件二次开发。需要满足的条件也和BSD类似：</p><ul><li>需要给代码的用户一份Apache Licence</li><li>如果你修改了代码，需要再被修改的文件中说明。</li><li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</li></ul></li><li><p>mit<br>允许将代码用作自己产品的开源，但需要保留原作者的版权声明。</p></li><li><p>GPL（GNU General Public License）<br>GPL严格要求使用了GPL类库（源码修改、类库引用、衍生品）的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成&#x2F;采用作为类库和二次开发的基础。</p></li><li><p>LGPL（GNU Lesser General Public License）<br>比 GPL 稍宽松，允许商业软件通过类库引用方式而无需开源。但如果需要修改源码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议，适合引用但不适合商业二次开发。</p></li><li><p>APGL-3.0<br>除非获得商业授权，否则无论以何种方式修改或者使用代码，都需要开源。</p></li><li><p>SSPL<br>允许修改源码，但如果要商业化则需要公开对源代码的修改，并获得 SSPL 的许可发布。</p></li></ol><h2 id="数据库对比"><a href="#数据库对比" class="headerlink" title="数据库对比"></a>数据库对比</h2><p>选取了一部分 active、且商业应用友好的时序数据库进行横向对比</p><h3 id="1-ClickHouse"><a href="#1-ClickHouse" class="headerlink" title="1. ClickHouse"></a>1. ClickHouse</h3><p>存储方式：列式存储<br>存储引擎:<br>场景：OLAP</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【网络】keep-alive机制</title>
      <link href="/post/db295f87.html"/>
      <url>/post/db295f87.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-keep-alive机制"><a href="#HTTP-keep-alive机制" class="headerlink" title="HTTP keep-alive机制"></a>HTTP keep-alive机制</h1><p>如果每次请求都要经过：三次握手建立 TCP连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; 四次挥手释放连接，那么此方式就是 HTTP 短连接，在 qps 较高的场景下效率较低，因此 HTTP 考虑要建立长连接，即在TCP连接上可以连续发送多个数据包，进行多轮次请求和响应。</p><p>反之，如果是一个静态页面，里面包含几个资源，使用短连接对服务器并发更好。</p><p>之前我们说过 HTTP 1.0就有了 keep alive参数支持长链接，但默认短链接。HTTP 1.1则默认支持长链接：<br><img src="/../images/keep-alive%E6%9C%BA%E5%88%B6/keep-alive%20%E5%8F%82%E6%95%B0.png"><br>如果要关闭，那么Connection 要设置为 close。</p><p>长链接需要保持 socket 文件句柄不被释放，当然这会占用内存和 cpu 资源，我们可以通过修改网络服务参数进行修改避免浪费资源。</p><p>例如 tomcat可以在server.xml中配置以下属性：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">keep</span>AliveTimeout <span class="comment">#服务器断开空闲连接的时间</span></span><br><span class="line"><span class="keyword">max</span>KeepAliveRequests <span class="comment">#服务器允许的最大空闲连接数</span></span><br></pre></td></tr></table></figure><p>nginx:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">keepalive_timeout</span> <span class="comment">#服务器断开空闲连接的时间</span></span><br><span class="line">keepalive_requests <span class="comment">#服务器允许的最大空闲连接数</span></span><br></pre></td></tr></table></figure><h2 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h2><p>客户端禁用了Keep-Alive，服务端默认开启了Keep-Alive, 那么：</p><ol><li>协商复用连接失败，也就是回退为短连接；</li><li>短链接也是 server 端主动断开连接，所以会有大量 time wait报警。</li></ol><h1 id="TCP-keep-alive"><a href="#TCP-keep-alive" class="headerlink" title="TCP keep alive"></a>TCP keep alive</h1><p>TCP 的 Keepalive 就是 TCP 的保活机制：</p><p>如果 TCP 双方一直没有数据交互（一般操作系统默认2小时），那么 TCP 协议栈就会发送探测报文，对端的响应有3种情况：</p><ol><li>ACK 响应：如果对端返回预期的 ACK，说明连接正常，应用程序不会收到通知（无需干预）。如果之后仍无数据传输，TCP 会在下一次超时时再次发送探测包。 </li><li>RST 响应：如果对端返回 RST，说明对端主机可能已经崩溃并重启，本地会关闭套接字。 </li><li>无响应：如果对端没有响应(网络异常、资源耗尽无法及时响应)，TCP 会认为连接中断并关闭套接字。</li></ol><blockquote><p>2小时，是操作系统和 TCP 协议栈的默认值：<br>windows : net.ipv4.tcp_keepalive_time: 7200000<br>macOs : net.inet.tcp.keepidle: 7200000</p></blockquote><p>如果只是进程崩溃会有操作系统回收进程，这个过程会发送 FIN 报文，而主机宕机时操作系统都来不及发送FIN 报文），那么 TCP 协议栈就会认为连接已经异常了，TCP 协议栈就会主动关闭连接。</p><p>TCP keep alive 默认是关闭的，可以通过以下参数开启：</p><ol><li>Java 中，应用程序一般通过设置 java.net.SocketOptions 中的 SO_KEEPALIVE 参数为 true 来开启 TCP 连接的 KeepAlive</li></ol><h1 id="HTTP-和-TCP-keep-alive的区别"><a href="#HTTP-和-TCP-keep-alive的区别" class="headerlink" title="HTTP 和 TCP keep alive的区别"></a>HTTP 和 TCP keep alive的区别</h1><ol><li>HTTP keep alive是应用程序实现的，目的是复用 tcp 连接发送多个数据报文，减少 TCP 建立释放的开销</li><li>TCP keep alive是操作系统实现的，目的是检测 TCP 连接的两端是否有异常关闭，如果 server 或 client 已经异常关闭，即应用层无法释放连接了，那么 TCP 协议栈就会主动关闭连接</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【网络】网络结构与代表协议</title>
      <link href="/post/15cc54a3.html"/>
      <url>/post/15cc54a3.html</url>
      
        <content type="html"><![CDATA[<p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.svg"></p><h1 id="一、网络整体架构"><a href="#一、网络整体架构" class="headerlink" title="一、网络整体架构"></a>一、网络整体架构</h1><h2 id="1-1-物理层-Physical-：比特-Bit"><a href="#1-1-物理层-Physical-：比特-Bit" class="headerlink" title="1.1 物理层(Physical)：比特(Bit)"></a>1.1 物理层(Physical)：比特(Bit)</h2><p>这一层是数据传输的物理方式。它包括局域网 (LAN) 内的所有物理组件。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理。</p><p>该层的设备：网卡，网线，集线器，中继器，调制解调器等</p><h2 id="1-2-数据链路层-Datalink-：帧-Frame"><a href="#1-2-数据链路层-Datalink-：帧-Frame" class="headerlink" title="1.2 数据链路层(Datalink)：帧(Frame)"></a>1.2 数据链路层(Datalink)：帧(Frame)</h2><p>在两个网络实体之间提供数据链路连接的建立、维持和释放管理，负责将接收到的比特组织成帧通过数据链路在不可靠的物理层上进行可靠传输。</p><ol><li>数据封装成帧：标志+地址段+控制段+数据段+校验序列+标志，首尾标志标识帧开始&#x2F;结束，控制段用于区分特殊功能的帧，如链路建立、拆除、监控等。</li><li>差错检测和控制：传输方本地 timer 计时器 + 帧尾部CRC纠错码，接收端对两个标志之间的帧内容进行校验。接收端发现错误可以请求重传错误帧或直接丢弃，传输端发现超时可以直接重传</li><li>流量控制：并不是数据链路层特有的功能，在这一层控制的是结点间链路上的流量，通过反馈信号帧知晓下游消费情况，如果超出消费能力则暂停发送。</li></ol><p>数据链路层由两个子层组成，即逻辑链路控制 (LLC) 和媒体访问控制 (MAC)：</p><ol><li>LLC子层：检测误差和请求重传错误帧。</li><li>MAC子层：确定物理地址，建立数据链路。平均分配存在竞争和高吞吐量节点之间的信道资源。例如 A 节点希望发送数据到 B节点，需要先发一个信号帧确认信道无冲突才能开始发送数据。</li></ol><p>该层的设备：网卡，网桥，网路交换机。</p><p>该层的协议：点对点协议、以太网</p><h2 id="1-3-网络层-Network-：数据包-Packet"><a href="#1-3-网络层-Network-：数据包-Packet" class="headerlink" title="1.3 网络层(Network)：数据包(Packet)"></a>1.3 网络层(Network)：数据包(Packet)</h2><p>寻址+路由，搜索数据到达目的地的最佳路径（最短路径），建立网络连接和为上层提供服务。</p><ol><li>路由选择：根据路由算法维护路由表，选择到目的地的最短路径。</li><li>拥塞控制：针对整个通信子网的全局控制：前期令牌桶控制准入+流量感知路由，后期ECN显示拥塞通知发送端，发送端收到后可以降低发送速率直到拥塞消除。但如果 ECN 也失效，就发生了我们说的丢包了,路由器会丢弃优先级低的数据包。</li><li>流量控制：通过令牌桶针对单个网络节点内的流量控制。</li></ol><p>该层的设备：三层交换机、路由器（在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备）</p><p>该层的协议：IP、ICMP</p><h2 id="1-4-传输层-Transport-：报文段-Segment"><a href="#1-4-传输层-Transport-：报文段-Segment" class="headerlink" title="1.4 传输层(Transport)：报文段(Segment)"></a>1.4 传输层(Transport)：报文段(Segment)</h2><p>决定如何发送会话层的数据（在必要时将数据进行分割），并对流程数据进行错误检测和验证。如果发现任何问题，它将在此阶段予以纠正。</p><ol><li>寻址</li><li>差错控制</li><li>流量控制</li><li>多路复用</li></ol><blockquote><p>网络层和传输层的区别？<br>传输层代码运行在用户的机器上，而网络层代码运行在运营商控制的路由器上，用户对网络层没有真正的控制权，需要通过传输层来提高网络服务质量。</p></blockquote><p>该层的协议：TCP、UDP</p><h2 id="1-5-会话层-套接字层-Session"><a href="#1-5-会话层-套接字层-Session" class="headerlink" title="1.5 会话层&#x2F;套接字层(Session)"></a>1.5 会话层&#x2F;套接字层(Session)</h2><p>负责在网络中的两节点之间建立、维持和终止通信。建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送，即不同机器上的用户之间会话的建立及管理。</p><h2 id="1-6-表示层-Presentation"><a href="#1-6-表示层-Presentation" class="headerlink" title="1.6 表示层(Presentation)"></a>1.6 表示层(Presentation)</h2><p>充当翻译器，对来自应用层的命令和数据进行解释，将数据编码为可识别的格式:</p><ol><li>如文本的 ASCII 格式和 UTF-8 格式编码和解码，</li><li>对数据进行压缩和解压，</li><li>数据加密解密</li></ol><h2 id="1-7-应用层-Application"><a href="#1-7-应用层-Application" class="headerlink" title="1.7 应用层(Application)"></a>1.7 应用层(Application)</h2><p>OSI参考模型的最高层，为用户的应用程序提供网络服务。例如单击网页以启动 HTTP 协议。</p><p>它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。</p><h1 id="二、TCP-UDP协议"><a href="#二、TCP-UDP协议" class="headerlink" title="二、TCP&#x2F;UDP协议"></a>二、TCP&#x2F;UDP协议</h1><h2 id="2-1-TCP"><a href="#2-1-TCP" class="headerlink" title="2.1 TCP"></a>2.1 TCP</h2><h3 id="2-1-1-TCP三次握手"><a href="#2-1-1-TCP三次握手" class="headerlink" title="2.1.1 TCP三次握手"></a>2.1.1 TCP三次握手</h3><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"><br>能够正确处理延迟的、重复的连接请求</p><blockquote><p>两次握手会有什么问题？(延迟、重复)<br>client 建立连接的请求1超时，直到发出的请求2都断开连接了，server 才收到请求1，如果是两次握手，那么 server 收到后回复 ACK 即建立连接，会浪费大量资源。 反之 client 三次握手可以返回 reject ，server 就不会建立连接，避免上面那种情况<br>如果 server 的 ACK 消息丢失，client 就无法开启监听，会一直等待直到超时（大量这种请求就会造成类似 SYN 攻击，占用 server 资源，最终导致系统瘫痪）。即便 client 发出 SYN 包后就开始监听，这种情况下也无法知道 server 的初始序列号 seq 号，所以需要三次握手。</p></blockquote><h3 id="2-1-2-TCP四次挥手"><a href="#2-1-2-TCP四次挥手" class="headerlink" title="2.1.2 TCP四次挥手"></a>2.1.2 TCP四次挥手</h3><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"><br>图中是 client 主动断开连接，如果是服务端断开连接就是相反的流程。主动断开方会进入time_wait状态。</p><h2 id="2-2-UDP"><a href="#2-2-UDP" class="headerlink" title="2.2 UDP"></a>2.2 UDP</h2><h2 id="2-3-TCP和UDP区别"><a href="#2-3-TCP和UDP区别" class="headerlink" title="2.3 TCP和UDP区别"></a>2.3 TCP和UDP区别</h2><ol><li>TCP 面向连接；UDP 面向无连接。</li><li>TCP可靠，适合数据可靠场景如传输文件；UDP不可靠，适合即时通讯场景如微信语音通话等，但传输效率相应也就更高。<blockquote><p>怎么理解 TCP 是可靠的？</p><ul><li>TCP 在数据传输时有确认、窗口、重传、拥塞机制，保证数据无差错、不丢失、不重复、按序到达。</li><li>UDP 在收到报文后不需要给出任何确认，因此无法保证数据丢失和按序到达</li></ul></blockquote></li><li>TCP 是有状态的，即 TCP 回去记录自己发送消息的状态（是否发送、是否被接收），因此需要维护复杂的连接状态表，但 UDP 是无状态的不需要做这些。</li><li>TCP 面向字节流，UDP 是面向数据报的。</li><li>TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li></ol><h1 id="三、HTTP-HTTPS协议"><a href="#三、HTTP-HTTPS协议" class="headerlink" title="三、HTTP&#x2F;HTTPS协议"></a>三、HTTP&#x2F;HTTPS协议</h1><h2 id="3-1-HTTP"><a href="#3-1-HTTP" class="headerlink" title="3.1 HTTP"></a>3.1 HTTP</h2><h3 id="3-1-1-HTTP-历史版本"><a href="#3-1-1-HTTP-历史版本" class="headerlink" title="3.1.1 HTTP 历史版本"></a>3.1.1 HTTP 历史版本</h3><p><strong>一般常用的是HTTP 1.1版本!!!</strong></p><h4 id="HTTP-0-9版本"><a href="#HTTP-0-9版本" class="headerlink" title="HTTP 0.9版本"></a>HTTP 0.9版本</h4><p>HTTP协议的第一个版本，功能简单，已弃用</p><ul><li>仅支持纯文本数据的传输，虽然支持HTML，但是不支持图片插入 </li><li>仅支持GET请求方式，且不支持请求头 </li><li>无状态，短连接。没有对用户状态的管理；每次请求建立一个TCP连接，响应之后关闭TCP连接。</li></ul><h4 id="HTTP-1-0版本"><a href="#HTTP-1-0版本" class="headerlink" title="HTTP 1.0版本"></a>HTTP 1.0版本</h4><ul><li>支持POST、GET、HEAD三种方法 </li><li>支持长连接keep-alive（但默认还是使用短连接：浏览器每一次请求建立一次TCP连接，请求处理完毕之后断开）。 </li><li>服务器不跟踪用户的行为也不记录用户过往请求。</li></ul><h4 id="HTTP-1-1版本"><a href="#HTTP-1-1版本" class="headerlink" title="HTTP 1.1版本"></a>HTTP 1.1版本</h4><p>新增PUT、DELETE、CONNECT、TRACE、OPTIONS方法，是现今使用最多的版本。 </p><ul><li>支持长连接，在一次TCP连接中可以发送多个请求或响应，且默认使用长连接。 </li><li>支持宽带优化、断点续传。请求的对象部分数据，可以不必发送整个对象；文件上传下载支持续传。 </li><li>因为长连接产生的问题：队头阻塞。长连接中，发送请求和响应都是串行化的，前面的消息会造成后面的消息也阻塞。解决方法是创建多个TCP连接，这样就可以基本保证了可用性，浏览器对同一个域名一般能并发建立 6 个连接，这些连接会维护 75 秒。</li></ul><h4 id="HTTP-2-0版本"><a href="#HTTP-2-0版本" class="headerlink" title="HTTP 2.0版本"></a>HTTP 2.0版本</h4><ul><li>二进制分帧，所有帧都是用二进制编码，节省了空间</li><li>多路复用：HTTP 2.0中所有的连接都是持久化的。相比1.1版本可以不用维护更多的TCP连接，在处理并发请求的时候，可以将多个数据流中互不依赖的帧可以乱序发送，同时还支持优先级。接收方接收之后可以根据帧头部信息将帧组合起来。（解决了1.1版本中的队头阻塞问题）</li><li>头部压缩：1.1版本每次传输都需要传输一份首部，2.0让双方各自缓存一份首部字段表，达到更快传输的目标。</li></ul><h4 id="HTTP-3-0版本"><a href="#HTTP-3-0版本" class="headerlink" title="HTTP 3.0版本"></a>HTTP 3.0版本</h4><blockquote><p>TTP&#x2F;3.0 之前是基于 TCP 协议的，而 HTTP&#x2F;3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议。因此不能说 HTTP 都是完全基于 TCP 的！</p></blockquote><ul><li>基于UDP的QUIC多路复用：在一个QUIC中可以并发发送多个HTTP请求Stream，且如果各个Stream互不依赖，那么就不会造成使用TCP带来的队头阻塞问题。这个问题源头上是因为TCP连接，TCP连接的性质决定了重传会影响队后的数据发送，所以干脆选用UDP来解决这个方案。 </li><li>0RTT建链：RTT表示Round-Trip Time，3.0可以实现0RTT建链。一般来说HTTPS协议要建立完整链接包括TCP握手和TLS握手，总计需要至少2-3个RTT，普通的HTTP协议也需要至少1个RTT才可以完成握手。基于UDP的QUIC协议可以在第一次发送包的时候直接发送业务数据。但是由于首次连接需要发送公钥数据，所以首次连接并不使用这一方法。</li></ul><h2 id="3-2-HTTPS"><a href="#3-2-HTTPS" class="headerlink" title="3.2 HTTPS"></a>3.2 HTTPS</h2><h1 id="四、IP-地址的分类"><a href="#四、IP-地址的分类" class="headerlink" title="四、IP 地址的分类"></a>四、IP 地址的分类</h1><p><img src="/../images/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/ip%E5%9C%B0%E5%9D%80.svg"><br>路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。</p><h2 id="划分子网和子网掩码"><a href="#划分子网和子网掩码" class="headerlink" title="划分子网和子网掩码"></a>划分子网和子网掩码</h2><p>划分子网是一个网络内部的事情，对外仍然表现为没有划分子网的网络。</p><ul><li>子网号subnet-id：主机号host-id借用若干个比特，即 ip 划分为了{net-id, subnet-id, host-id} </li><li>子网掩码：net-id, subnet-id都为1，host-id为0；数据报仍然先按照net-id找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。</li></ul><h2 id="无类域间路由CIDR"><a href="#无类域间路由CIDR" class="headerlink" title="无类域间路由CIDR"></a>无类域间路由CIDR</h2><p>CIDR 消除了传统的A类、B类和C类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间；</p><p>CIDR使用13～27位不等的“网络前缀” 来代替分类IP地址中的网络号和子网号，IP地址从三级编址（网络号、子网号、主机号）又回到了两级编址（网络前缀、主机号）。如：</p><p>21.3.56.45&#x2F;25 表示前 25个 bit 是网络前缀，32 - 25 &#x3D; 7个 bit 是主机号，路由时遵循最长前缀匹配原则。</p><h1 id="五、Q-A"><a href="#五、Q-A" class="headerlink" title="五、Q &amp; A"></a>五、Q &amp; A</h1><h2 id="单机最大-TCP-并发连接数？"><a href="#单机最大-TCP-并发连接数？" class="headerlink" title="单机最大 TCP 并发连接数？"></a>单机最大 TCP 并发连接数？</h2><ul><li>系统标识一个 TCP 连接：{源 IP，源端口，目的 IP，目的端口} </li><li>系统标识一个 socket 连接句柄：{协议类型，源 IP，源端口，目的 IP，目的端口}</li></ul><ol><li>client 最大 TCP 连接数</li></ol><p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，一个client最大tcp连接数为65535，这些连接可以连到不同的serverip。</p><ol start="2"><li>server最大tcp连接数</li></ol><p>server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remoteip（也就是clientip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。</p><ol start="3"><li>实际的tcp连接数</li></ol><p>上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix&#x2F;linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。</p><p>对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万,甚至上百万是没问题的</p><ol start="4"><li>相关linux参数调整</li></ol><p>sysctl -w fs.file-max&#x3D;10485760 #系统允许的文件描述符数量10m<br>sysctl -w net.ipv4.tcp_rmem&#x3D;1024 #每个tcp连接的读取缓冲区1k，一个连接1k<br>sysctl -w net.ipv4.tcp_wmem&#x3D;1024 #每个tcp连接的写入缓冲区1k<br>sysctl -w net.ipv4.ip_local_port_range&#x3D;’1024 65535’ #修改默认的本地端口范围<br>sysctl -w net.ipv4.tcp_tw_recycle&#x3D;1 #快速回收time_wait的连接<br>sysctl -w net.ipv4.tcp_tw_reuse&#x3D;1<br>sysctl -w net.ipv4.tcp_timestamps&#x3D;1 #用户单进程的最大文件数，用户登录时生效<br>echo ‘* soft nofile 1048576’ &gt;&gt; &#x2F;etc&#x2F;security&#x2F;limits.conf<br>echo ‘* hard nofile 1048576’ &gt;&gt; &#x2F;etc&#x2F;security&#x2F;limits.conf<br>ulimit -n 1048576 #用户单进程的最大文件数 当前会话生效</p><h2 id="访问网页的全过程"><a href="#访问网页的全过程" class="headerlink" title="访问网页的全过程"></a>访问网页的全过程</h2><ol><li><p>在浏览器中输入指定网页的 URL。</p></li><li><p>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</p></li><li><p>浏览器根据 IP 地址和端口号，向目标服务器发起 TCP 连接请求。<br>在使用 HTTP1.1 协议时，一个 TCP 连接只能同时处理 1个 HTTP 请求，在网页需要请求大量资源（图片等），为提高效率需要建立多个 TCP 连接。Chrome浏览器最多对同一个域名建立 6 个 TCP 连接（不同浏览器实现不同），多余的请求需要 pending 等待空闲连接。6个 TCP 连接会使用浏览器实现</p></li><li><p>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</p></li><li><p>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</p></li><li><p>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</p></li><li><p>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【多线程系列】线程池</title>
      <link href="/post/b1e4f1fa.html"/>
      <url>/post/b1e4f1fa.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Redis系列】redis 概况与常见命令</title>
      <link href="/post/29f41d47.html"/>
      <url>/post/29f41d47.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p>Redis 官网：<a href="https://redis.io/">https://redis.io/</a><br>源码地址：<a href="https://github.com/redis/redis">https://github.com/redis/redis</a><br>Redis 命令参考：<a href="http://doc.redisfans.com/">http://doc.redisfans.com/</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis全称为：Remote Dictionary Server（远程数据服务），是一种支持key-value等多种数据结构的存储系统，也是互联网技术领域中使用最广泛的缓存中间件。<br>可用于缓存，事件发布或订阅，高速队列等多种常见场景。支持多种数据结构，基于内存快速读写，也可通过快照持久化到磁盘。</p><blockquote><p>为什么 redis</p></blockquote><h1 id="支持的数据结构"><a href="#支持的数据结构" class="headerlink" title="支持的数据结构"></a>支持的数据结构</h1><p>最基础的5种数据类型：</p><ol><li>string（字符串）</li><li>hash（哈希）</li><li>list（列表）</li><li>set（集合）</li><li>zset(sorted set：有序集合)<br>其他还有：</li><li>bitmaps（位图） </li><li>HyperLogLog（基数估算）</li><li>GEO（地理信息定位）等</li></ol><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>key 类型是 string，value 类型可以是 string、数字、二进制</p><ul><li>value 值最大能存储512MB。</li><li>value 是二进制安全的，即redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</li></ul><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>key 类型是 hash，value 类型为键值对（一张map）。</p><ul><li>方便结构化存储一个对象信息</li><li>方便读写序列化和反序列化</li></ul><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>不是键值对，是一个简单的字符串列表</p><ul><li>按照插入顺序排序</li><li>新元素可以选择插在 list 头或尾部<br>在消息队列、文章列表等场景中经常使用</li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>不是键值对，是一个简单的无序字符串集合，集合中元素唯一<br>在例如共同关注、标签等场景中经常使用</p><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>不是键值对，是一个有序字符串集合，比 set 多了一个排序属性 score<br>每个元素都关联一个double类型的分数score，通过分数排序，分数可以重复。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>C 语言中使用字符数组来表示字符串，并在字符串末尾使用空字符 \0 标识字符串结束。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str1 = <span class="string">&quot;hello\x00her-cat&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str1: %lu\n&quot;</span>, <span class="built_in">strlen</span>(str1));</span><br><span class="line"><span class="comment">// 输出str1: 5</span></span><br></pre></td></tr></table></figure><p>即 strlen 函数是通过遍历字符串来计算长度的，时间复杂度为 O(n)。在遍历的过程中，如果某个字符等于 \0，<br>就会停止遍历并返回第一个字符到该字符的字符数量，提前停止遍历，导致得到错误的字符串长度。<br>所以我们称 C 语言中的 strlen 函数是非二进制安全的。<br>而 Redis 的字符串是二进制安全的，设计了 SDS（Simple Dynamic String） 数据结构，又称简单动态字符串，结构体大概如下（3.x 版本，后续版本可能有变动）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">   <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">   <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">   <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">   <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">   <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优点:</p><ul><li>O(1)复杂度就能获取字符串长度(使用sds可以确保获取字符串长度操作不会成为Redis的瓶颈)</li><li>杜绝缓冲区溢出(sds在拼接字符串之前会判断剩余空间是否满足需求，不满足会先执行扩容操作)</li><li>SDS根据长度判断字符串结束的位置，解决了二进制不安全的问题(这就使得Redis不仅可以保存文本数据，还可以是任意二进制数据)</li><li>降低了修改字符串时带来的内存重分配次数，提高了性能(空间预分配，和惰性空间释放)</li></ul><h2 id="hash-1"><a href="#hash-1" class="headerlink" title="hash"></a>hash</h2><p>hash用于存储对象，对象的结构为属性、值。比如：用户id为10000的用户信息，包含id、name、age三个属性。<br>hash是一个string类型的field和value的映射表，hash特别适合存储对象。</p><h2 id="list-1"><a href="#list-1" class="headerlink" title="list"></a>list</h2><p>list是字符串链表，按照插入顺序排序。<br>可以添加一个元素到列表的头部（左边）或者尾部（右边），另一个列表从右边插入或者左边。<br>比如：在微博应用中，可以将一个用户所有的关注人存在一个列表里，将其所有粉丝存在一个列表里。</p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis是内存数据库，为了保证数据的安全性，它提供了两种持久化的方案。<br>RDB：基于快照的持久化，对redis进行周期性的备份。<br>AOF：以追加的方式记录redis操作日志的文件。可以最大程度的保证redis数据的完整性。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="1-统计"><a href="#1-统计" class="headerlink" title="1. 统计"></a>1. 统计</h2><ul><li>访问次数<br>定义一个key，比如：OFFICIAL_INDEX_VISIT_COUNT。<br>在Redis中有incr命令，可以实现给value值加1操作：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr OFFICIAL_INDEX_VISIT_COUNT</span><br></pre></td></tr></table></figure>当然如果想一次加的值大于1，可以用incrby命令，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby OFFICIAL_INDEX_VISIT_COUNT 5</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-限流"><a href="#2-限流" class="headerlink" title="2.限流"></a>2.限流</h2><p>一分钟只能发送一次验证码，一小时只能发送10次验证码等等多种规则的限流<br>短时间内某个 ip 进行DDos攻击，需要限制一个ip一分钟只能访问10次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET  1 EX 60</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR rate_limit:&lt;ip&gt;</span><br></pre></td></tr></table></figure><h2 id="3-内存缓存"><a href="#3-内存缓存" class="headerlink" title="3. 内存缓存"></a>3. 内存缓存</h2><p>部分多读少写的数据，可以使用Redis做内存缓存。例如一个 db 信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h2><p>分布式锁可能是使用Redis最常见的场景之一，相对于其他的分布式锁，比如：数据库分布式锁或者Zookeeper分布式锁，基于Redis的分布式锁，有更好的性能，被广泛使用于实际工作中。</p><p>我们使用下面这段代码可以加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面这段代码在有些场景下，会有一些问题，释放锁可能会释放了别人的锁。<br>说实话Redis分布式锁虽说很常用，但坑也挺多的，如果用不好的话，很容易踩坑。</p><h2 id="5-排行榜"><a href="#5-排行榜" class="headerlink" title="5. 排行榜"></a>5. 排行榜</h2><p>Redis的zset数据结构可以用来实现排行榜应用场景。<br>比如，微博上有个好友动态的页面，需要展示用户的最新动态，而且要实时更新。<br>如果用关系型数据库，需要频繁地查询数据库，效率很低。<br>通常情况下，我们可以使用Sorted Set保存排行榜的数据。<br>使用ZADD可以添加排行榜的数据，使用ZRANGE可以获取排行榜的数据。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZADD rank:score 100 &quot;周星驰&quot;</span><br><span class="line">ZADD rank:score 90 &quot;周杰伦&quot;</span><br><span class="line">ZADD rank:score 80 &quot;周润发&quot;</span><br><span class="line">ZRANGE rank:score 0 -1 WITHSCORES</span><br></pre></td></tr></table></figure><p>返回数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;周星驰&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;周杰伦&quot;</span><br><span class="line">4) &quot;90&quot;</span><br><span class="line">5) &quot;周润发&quot;</span><br><span class="line">6) &quot;80&quot;</span><br></pre></td></tr></table></figure><h2 id="6-位统计"><a href="#6-位统计" class="headerlink" title="6. 位统计"></a>6. 位统计</h2><p>统计一周内连续登陆的用户，以及一个月内登陆过的用户。<br>如果使用传统的数据库，实现起来比较麻烦，但使用Redis的bitmap让我们可以实时的进行类似的统计。<br>比如现在有个需求：有个网站需要统计一周内连续登陆的用户，以及一个月内登陆过的用户。</p><p>bitmap 是二进制的byte数组，也可以简单理解成是一个普通字符串。它将二进制数据存储在byte数组中以达到存储数据的目的。</p><p>保存数据命令使用setbit，语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure><p>具体示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit user:view:2024-01-17 123456 1</span><br></pre></td></tr></table></figure><p>往bitmap数组中设置了用户id&#x3D;123456的登录状态为1，标记2024-01-17已登录。</p><p>然后通过命令getbit获取数据，语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure><p>具体示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit user:view:2024-01-17 123456</span><br></pre></td></tr></table></figure><p>如果获取的值是1，说明这一天登录了。<br>如果我们想统计一周内连续登录的用户，只需要遍历用户id，根据日期中数组中去查询状态即可。</p><h2 id="7-分类树"><a href="#7-分类树" class="headerlink" title="7. 分类树"></a>7. 分类树</h2><p>在很多网站都有分类树的功能，如果没有生成静态的html页面，想通过调用接口的方式获取分类树的数据。<br>我们一般为了性能考虑，会将分类树的json数据缓存到Redis当中，为了后面在网站当中能够快速获取数据。<br>不然在接口中需要使用递归查询数据库，然后拼接成分类树的数据结构。</p><p>这个过程非常麻烦，而且需要多次查询数据库，性能很差。</p><p>因此，可以考虑用一个定时任务，异步将分类树的数据，直接缓存到Redis当中，定义一个key，比如：MALL_CATEGORY_TREE。</p><p>然后接口中直接使用MALL_CATEGORY_TREE这个key从缓存中获取数据即可。</p><p>可以直接用key&#x2F;value字符串保存数据。</p><h2 id="8-消息队列"><a href="#8-消息队列" class="headerlink" title="8. 消息队列"></a>8. 消息队列</h2><p>我们说起队列经常想到是：kafka、rabbitMQ、RocketMQ等这些分布式消息队列。</p><p>其实Redis也有消息队列的功能，我们之前有个支付系统，就是用的Redis队列功能。</p><p>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。</p><p>顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。对应channel发送消息后，所有订阅者都能收到相关消息。</p><p>在java代码中可以实现MessageListener接口，来消费队列中的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisMessageListenerListener</span> <span class="keyword">implements</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, <span class="type">byte</span>[] pattern)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(pattern);</span><br><span class="line">        RedisSerializer&lt;?&gt; valueSerializer = redisTemplate.getValueSerializer();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">deserialize</span> <span class="operator">=</span> valueSerializer.deserialize(message.getBody());</span><br><span class="line">        <span class="keyword">if</span> (deserialize == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5DigestAsHex</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(deserialize.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(md5DigestAsHex, <span class="string">&quot;1&quot;</span>, <span class="number">20</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.equals(result)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;接收的结果：&#123;&#125;&quot;</span>, deserialize.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;其他服务处理中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-分布式session"><a href="#9-分布式session" class="headerlink" title="9. 分布式session"></a>9. 分布式session</h2><h2 id="10-生成全局-ID"><a href="#10-生成全局-ID" class="headerlink" title="10. 生成全局 ID"></a>10. 生成全局 ID</h2><p>在有些需要生成全局ID的业务场景，其实也可以使用Redis。 可以使用incrby命令，利用原子性操作，可以执行下面这个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby userid 10000</span><br></pre></td></tr></table></figure><p>在分库分表的场景，对于有些批量操作，我们可以从Redis中，一次性拿一批id出来，然后给业务系统使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【感悟思考】知行合一</title>
      <link href="/post/ffc9e095.html"/>
      <url>/post/ffc9e095.html</url>
      
        <content type="html"><![CDATA[<p>[转天涯帖]</p><p>一个思想深邃的年轻人大概率会一事无成。因为他的灵魂走在了年龄的前面。请相信这样一句话，如果你没有去亲身实践你所懂的道理，当这样的道理你懂得越多，你就越割裂，就越无法走在人生的道路上。</p><p>很多年轻人很小就会思考生命的意义，他们自觉不是乌合之众，也能很快从现象中看到本质，摸清一些社会运转的规律。但是你会被一些东西反噬，你的精神的宫殿铸就得就越是红了。你知道的太多，想要的太多，害怕的太多，继而失望的也越多，无能为力的感觉和生活的灰色地带也越多。这种复杂嵌套的思维结构想的越多，行动力就越低，在思想上不断做加法，在行动上就不断做减法，因为你每一分钟都会停下来复盘且怀疑，这时你就会突然发现自己困在某个地方，动弹不得了，这便是思想上的自愧，这是聪明人的弊端。</p><p>不要觉得自己的思想很深刻，思想是会随着静转而变化的，你需要弯腰去做一些你自以为已经懂得的小事，去成长，去积累，去接触，去身体力行的感受这个社会。如果感觉思想停滞不前，那就说明一定是思想走得太快，你需要去等等你的身体需要你去花费时间在实践上，然后你的思想才会更进一步，这两者永远是相辅相成的。如果你说你非要等到所有的精神蓝图都已经规划好了再去行动，抱歉，你等不到你的现实痛苦的来源，习惯了思考的天马行空，日行千里，回归现实一坎，地久天长，遥遥无期，合抱之母，身为豪梦。你想的越多，你就越难开始。</p>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】概论</title>
      <link href="/post/4da4efb3.html"/>
      <url>/post/4da4efb3.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>在学习计组之后来看这个问题，我们已经有了一台可读写、计算、存储的电子计算机，CPU在收到相关指令后可以进行去对应地址读取指令和数据进行计算。但这离现在我们能使用的电脑还差十万八千里，我们现在只需要打开电脑，然后就会有大量已经在运行的程序，无需用户手动输入指令，只需要点按鼠标即可进行傻瓜操作。<br>我们先不管这些软件是如何开发的，思考一个更底层的问题，计算机是怎么做到这么多程序管理的呢？CPU和内存、磁盘，甚至网卡、声卡、显卡等资源 在多个程序中间又怎样去协调呢？这些程序又是以怎样的逻辑运行起来的呢？这个过程中进程和内存、外存的通信又是怎样实现的呢？</p><p>先来明确几个概念：</p><h2 id="操作系统在计算机系统中的位置"><a href="#操作系统在计算机系统中的位置" class="headerlink" title="操作系统在计算机系统中的位置"></a>操作系统在计算机系统中的位置</h2><p>在硬件和应用程序之间。<br>Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。</p><h2 id="操作系统处理的问题"><a href="#操作系统处理的问题" class="headerlink" title="操作系统处理的问题"></a>操作系统处理的问题</h2><ul><li>CPU调度</li><li>内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ul><li>并发</li><li>共享</li><li>虚拟：磁盘-&gt;文件，内存-&gt;地址空间，让每一个用户觉得的有一个计算机专门为他服务</li><li>异步：程序是走走停停，而不是一直运行</li></ul><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul><li>并发：指的是多个事情，在同一时间段内同时发生了。并发的多个任务之间是互相抢占资源的。</li><li>并行：指的是多个事情，在同一时间点上同时发生了。只有在多CPU的情况中才会发生。</li></ul><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><ul><li>进程可以有0~多个线程，但是线程只能依赖于进程</li><li>进程有自己独立的地址空间，进程的线程共享进程拥有的地址空间</li><li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I&#x2F;O、cpu等； </li><li>在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销； </li><li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行； </li><li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开发工具】Gradle使用手册</title>
      <link href="/post/274a496e.html"/>
      <url>/post/274a496e.html</url>
      
        <content type="html"><![CDATA[<p>在整理老项目的过程中，部分老项目使用的是gradle，由于groovy的拓展脚本，学习成本比maven要高一些，因此记录一些常用的命令和配置方便进行回顾。</p><p>首先，一定要注意gradle使用的版本，我自己就是因为要兼容Mac M1，操作了gradle 2.0 -&gt; 5.6.4的版本升级，导致许多插件、groovy语法都出现兼容问题，花费了很多时间去处理编译和运行的问题。</p><p>首先，最好的系统学习方法，就是在官网选择使用的版本，有详细实例和语法可以参考。例如<a href="https://docs.gradle.org/5.6.4/userguide/tutorial_using_tasks.html">5.6.4版本使用说明</a>。</p><p>下面进入正题。</p><h1 id="一、Gradle安装使用"><a href="#一、Gradle安装使用" class="headerlink" title="一、Gradle安装使用"></a>一、Gradle安装使用</h1><p>目前gradle的使用主要有两种方式：</p><ol><li>在官网下载gradle安装包，解压后配置环境变量</li></ol><h1 id="二、Gradle常用命令"><a href="#二、Gradle常用命令" class="headerlink" title="二、Gradle常用命令"></a>二、Gradle常用命令</h1><h2 id="2-1-Gradle-Task"><a href="#2-1-Gradle-Task" class="headerlink" title="2.1 Gradle Task"></a>2.1 Gradle Task</h2><p>首先，Gradle最核心的概念为task，不同task解决不同类型的功能，例如编译、打包，甚至大多数plugin也是通过拓展task类型来实现功能的。</p><p>gradle会根据用户的构建脚本，以及相关task之间配置的dependency，将这些task构建为有向无环图（DAG）。也就是说，build本质上是配置一组任务，并根据它们之间的依赖关系将它们连接起来，从而创建 DAG。任务图创建完成后，Gradle 会确定哪些任务需要按顺序运行，然后开始执行。</p><h3 id="2-1-1-Gradle-Task生命周期"><a href="#2-1-1-Gradle-Task生命周期" class="headerlink" title="2.1.1 Gradle Task生命周期"></a>2.1.1 Gradle Task生命周期</h3><p>Gradle 任务的生命周期包括以下阶段：</p><ul><li>clean: 清理任务，删除build目录</li><li>check: 检查任务，用户也可以使用check.dependsOn(task)来做一些前置检查</li><li>assemble: 编译与打包，</li><li>build(depends on: check, assemble): 构建任务，包括运行运行测试、生成文档等。</li><li>buildConfiguration: assemble那些附加到已命名配置的工件。例如，buildArchives 将执行创建附加到归档配置的任何工件所需的任何任务。</li><li>uploadConfiguration: 与 buildConfiguration 的功能相同，但也会上传所有附加到给定配置的工件。</li><li>cleanTask: 清理Task产出的output</li></ul><h2 id="2-2-Gradle-初始化顺序"><a href="#2-2-Gradle-初始化顺序" class="headerlink" title="2.2 Gradle 初始化顺序"></a>2.2 Gradle 初始化顺序</h2><p>以IDEA为例。在Gradle项目初始化时，会先读取setting.gradle脚本，这个最重要的是定义了整个项目的模块，idea需要感觉这个模块来识别各个子模块。</p><h1 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h1><h2 id="3-1-task依赖后的执行顺序"><a href="#3-1-task依赖后的执行顺序" class="headerlink" title="3.1 task依赖后的执行顺序"></a>3.1 task依赖后的执行顺序</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> taskX &#123;</span><br><span class="line">    dependsOn <span class="string">&#x27;taskY&#x27;</span></span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskX1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskX2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    configure &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskX3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">task</span> taskY &#123;</span><br><span class="line">    <span class="keyword">doFirst</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskY1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskY2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    configure &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">&#x27;taskY3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行：<code>gradle -q taskX</code></p><p>执行结果：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">taskX3</span></span><br><span class="line">taskY3</span><br><span class="line">taskY1</span><br><span class="line">taskY2</span><br><span class="line">taskX1</span><br><span class="line">taskX2</span><br></pre></td></tr></table></figure><p>也就是说，task会按照依赖关系，先执行被依赖的task，再执行自己。在单个task而言，执行顺序为configure-&gt; doFirst -&gt; doLast。<br>其中configure是个例外，即便依赖其他task，也要先初始化好自己的配置，才会加载被依赖对象的configure。很好理解，配置先行，然后才是执行阶段。</p><h2 id="3-2-动态Task"><a href="#3-2-动态Task" class="headerlink" title="3.2 动态Task"></a>3.2 动态Task</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列-rabbitMQ</title>
      <link href="/post/24a1a957.html"/>
      <url>/post/24a1a957.html</url>
      
        <content type="html"><![CDATA[<h1 id="rabbitMQ是什么"><a href="#rabbitMQ是什么" class="headerlink" title="rabbitMQ是什么"></a>rabbitMQ是什么</h1><p>(官网)[<a href="https://www.rabbitmq.com/]">https://www.rabbitmq.com/]</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【消息队列】基础</title>
      <link href="/post/fec99276.html"/>
      <url>/post/fec99276.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、消息队列（Message-Queue"><a href="#一、消息队列（Message-Queue" class="headerlink" title="一、消息队列（Message Queue)"></a>一、消息队列（Message Queue)</h1><h2 id="1-1-什么是消息队列？"><a href="#1-1-什么是消息队列？" class="headerlink" title="1.1 什么是消息队列？"></a>1.1 什么是消息队列？</h2><p>消息队列是一种异步的服务间通信方式，这里的服务也可以理解为不同线程&#x2F;进程。这种通信方式有这样几个特征：</p><ol><li>消息队列是<strong>点到点</strong>的传输，发送方提交Message到MQ，接收方从MQ中取出Message进行消费；</li><li>消息及相关信息在被消费或删除之前一直<strong>存储</strong>在队列上；</li><li>按照一定的<strong>顺序</strong>（例如时间或重要性）进行排序。</li><li>每条消息一般仅可被一位用户消费一次。</li><li>消息队列本身是<strong>异步</strong>的，它允许接受者在发送消息很长时间后，才被消费者消费（对比RPC协议们（如HTTP）都是同步的，客户端在请求后并需等待服务端返回响应）。</li></ol><blockquote><p>可以看到由于中间的Message是由Queue存储的，并没有进行持久化，因此一般这种类型对Message大小和流量是有限制的，超出限制后，Queue可能会进行阻塞，或者丢弃消息，当然各个产品实现细节可能不尽相同。</p><p>另外，由于消费者是需要自己定时去轮询队列进行消费的，因此也能控制下游服务的压力，将消息积压在队列中，再不丢消息的情况下，整体上会表现出对上游压力的削峰，提升服务稳定性。</p></blockquote><h2 id="1-2-和其他服务通信方式的区别"><a href="#1-2-和其他服务通信方式的区别" class="headerlink" title="1.2 和其他服务通信方式的区别"></a>1.2 和其他服务通信方式的区别</h2><p>消息队列最大的功劳应该是它解耦了服务发布方和订阅方，试想这样一个场景：<br>一个商城系统，用户在支付完成后涉及到多个服务，比如：</p><ol><li>订单系统需要记录订单</li><li>积分系统需要增加积分</li><li>通知系统需要通知用户确认地址、商家确认新订单</li><li>仓库系统需要统计出库</li></ol><p>……<br>如果我们使用RPC，线性处理后面几个服务，那么：</p><ol><li>接口时间过长，影响用户体验</li><li>一旦有某个服务挂了，整个流程都会被阻塞（试想长时间的retry），并且由于上下游耦合，有可能经常因为某个小模块挂了导致整个流程失败；</li><li>如果服务挂了就将这一单置为失败，那么用户体验会变差，降低用户体验；如果要在后台重试，那么需要额外开发存储失败记录并重试逻辑，耦合的这部分存储成本并不优雅，同时大家都知道这种情况下多模块之间一旦有接口之间的变动有多痛苦……</li></ol><p>消息队列就是这种场景的一个解决方案，上游只需要将Message发送到对应MQ，下游服务消费即可。</p><h2 id="1-3-消息队列的实现"><a href="#1-3-消息队列的实现" class="headerlink" title="1.3 消息队列的实现"></a>1.3 消息队列的实现</h2><p>目前消息队列所使用的协议有很多种，例如最简洁的MQTT，以及更加丰富的AMQP。</p><p>基于不同的协议有不同的产品， 如Apache ActiveMQ、Apache RocketMQ、Alibaba RocketMq、RabbitMQ、Kafka、HTTPSQS等。</p><h1 id="二、MQTT协议"><a href="#二、MQTT协议" class="headerlink" title="二、MQTT协议"></a>二、MQTT协议</h1><p>MQTT（Message Queuing Telemetry Transport）是IBM开发的一个应用层即时通讯协议(MQTT是在TCP传输协议之上的)，据 Arlen Nipper 在 IBM Podcast 上的自述，MQTT 原名是 MQ TT，注意 MQ 与 TT之间的空格。这是九十年代早期他在参与 Conoco Phillips 公司的一个原油管道数据采集监控系统（pipeline SCADA system）时开发的一个实时数据传输协议。它的目的在于让传感器通过带宽有限的 VSAT ，与 IBM 的 MQ Integrator 通信。由于 Nipper 是遥感和数据采集监控专业出身，所以按业内惯例取了 MQ TT 这个名字。</p><p>它有这样几个特点：</p><ol><li><strong>基于发布&#x2F;订阅</strong>实现，因此可以支持一对多的消息分发机制，消息通过MQTT Broker分发到各个Subscriber；</li><li><strong>轻量级协议</strong>，数据包更小，实现简单，在计算和内存资源需求上需求也就更少，在资源受限的设备上运行会非常高效；</li><li>MQTT一般是不会存储队列；</li><li><strong>双向通信</strong>，各个Subscriber可以向topic发布消息，也可以订阅接收topic上的消息；</li></ol><h2 id="2-1-消息服务质量等级QoS（Quality-of-Service）"><a href="#2-1-消息服务质量等级QoS（Quality-of-Service）" class="headerlink" title="2.1 消息服务质量等级QoS（Quality of Service）"></a>2.1 消息服务质量等级QoS（Quality of Service）</h2><p>MQTT的设计目标就是为了资源最紧缺的设备也能够安全运行，考虑设备所在网络的不确定性，MQTT 协议提供了 3 种消息服务质量等级（Quality of Service），保证了在不同的网络环境下消息传递的可靠性：</p><ol><li><p>QoS 0：消息最多传递一次。<br>发布者发送一条消息之后，就不再关心它有没有发送到对方，也不设置任何重发机制，因此消息传递完全依赖于TCP，可靠性较差，如果TCP关闭或重置都会丢失缓冲区消息，但接收方消费的消息不会重复。<br><img src="/../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Qos0.jpg"></p></li><li><p>QoS 1：消息传递至少 1 次。<br>包含了简单的重发机制，发布者发送携带的Packet ID的消息，然后等待接收者的 ACK，如果收到携带相同Packet ID的 ACK 则从缓存中删除该消息，否则重新发送消息。<br>这种模式能保证消息至少能到达一次，但如果由于网络问题丢失了ACK，那么消息可能会被重复发送。<br><img src="/../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Qos1.jpg"></p></li><li><p>QoS 2：消息仅传送一次。<br>设计了重发和重复消息发现机制，保证消息到达对方并且严格只到达一次。但这种方法意味着要使用类似三次握手的机制反复确认消息的接收情况，传输效率相应也就会降低。<br>比如Qos1，前半段流程是类似的，区别在于在发送方收到对应ACK后，还需要额外发送一次PUBREL报文，通知接收方准备释放这个Packet ID，接收方也需要存储Packet ID，对于<br><img src="/../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Qos2.jpg"></p></li></ol><h2 id="2-2-MQTT-vs-其他协议"><a href="#2-2-MQTT-vs-其他协议" class="headerlink" title="2.2 MQTT vs 其他协议"></a>2.2 MQTT vs 其他协议</h2><h3 id="2-2-1-MQTT-vs-HTTP"><a href="#2-2-1-MQTT-vs-HTTP" class="headerlink" title="2.2.1 MQTT vs HTTP"></a>2.2.1 MQTT vs HTTP</h3><p>MQTT 的最小报文仅为 2 个字节，比 HTTP 占用更少的网络开销。<br>MQTT 与 HTTP 都能使用 TCP 连接，并实现稳定、可靠的网络连接。<br>MQTT 基于发布订阅模型，HTTP 基于请求响应，因此 MQTT 支持双工通信。<br>MQTT 可实时推送消息，但 HTTP 需要通过轮询获取数据更新。<br>MQTT 是有状态的，但是 HTTP 是无状态的。<br>MQTT 可从连接异常断开中恢复，HTTP 无法实现此目标。</p><h3 id="2-2-2-MQTT-vs-XMPP"><a href="#2-2-2-MQTT-vs-XMPP" class="headerlink" title="2.2.2 MQTT vs XMPP"></a>2.2.2 MQTT vs XMPP</h3><p>MQTT 协议设计简单轻量、路由灵活，将在移动互联网、物联网消息领域，全面取代 PC 时代的 XMPP 协议。</p><p>MQTT 报文体积小且编解码容易，XMPP 基于繁重的 XML，报文体积大且交互繁琐。<br>MQTT 基于发布订阅模式，相比 XMPP 基于 JID 的点对点消息路由更为灵活。<br>MQTT 支持 JSON、二进制等不同类型报文。XMPP 采用 XML 承载报文，二进制必须 Base64 编码等处理。<br>MQTT 通过 QoS 保证消息可靠传输，XMPP 主协议并未定义类似机制。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议、消息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【方案设计】分布式心跳检测方案Phi-Accrual-FailureDetector</title>
      <link href="/post/23ac10a5.html"/>
      <url>/post/23ac10a5.html</url>
      
        <content type="html"><![CDATA[<p>最近由于架构调整刚接手的一个新产品，发现其心跳检测方案存在一些问题。产品本身原来是通过k8s开启headless，然后通过dns解析获取到所有pod的ip，然后通过请求服务的健康检测接口是否返回，来判断服务是否存活。消亡的节点会被放进黑名单中，黑名单会定时失效，失效以后可以再次通过心跳任务来检测服务是否失效。</p><p>但由于线上某个网络组件问题，导致某个节点DNS虽然能稳定解析出某个节点，但是会时不时发送消息失败，导致这个节点反复出入黑名单。线上一些大流量客户甚至可感延迟，导致客户体验很差。</p><p>想到之前对cassandra较为熟悉，因此我打算仔细调研一下cassandra使用的Phi-Accrual FailureDetector心跳方案，通过可信度来决定是否剔除节点，而不是通过单次访问的结果进行判断，当然还有其他简单的解决方案可以采用，但学习一下优秀的设计方案，还是很有必要的。</p><p>那么我们开始吧。</p><h1 id="什么是Phi-Accrual-FailureDetector"><a href="#什么是Phi-Accrual-FailureDetector" class="headerlink" title="什么是Phi-Accrual FailureDetector"></a>什么是Phi-Accrual FailureDetector</h1><p>Phi-Accrual FailureDetector是Google提出的一种心跳检测方案，cassandra的FailureDetector类注解中提到，『This FailureDetector is an implementation of the paper titled “The Phi Accrual Failure Detector” by Hayashibara.』(<a href="https://ieeexplore.ieee.org/document/1353004">原文</a>)。结合论文和源码实现，我们能更好地理解这种阈值和积累型故障检测器。</p><blockquote><p>作者是京都产业大学信息科学与工程学院的教授，主要研究都是围绕着分布式服务探测和网络协议。</p></blockquote><p>累积行故障检测器相对传统心跳检测，有1个主要区别：<br>如果只根据是否能接收到心跳来判断，那么节点状态就只有死亡和存活两种状态。但实际上两者中间由于网络波动，并不是这样一个二态关系，中间还有一种suspect状态。</p><p>因此系统可以用一个连续的『可信度』来描述节点是否有故障，这个值我们用Phi表示，并且增加一个失效阈值，从而调整故障检测器的敏感度，敏感度小表示敏感度更高，反之更低，不过两者一般不是成一个线性关系。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="累积分布函数"><a href="#累积分布函数" class="headerlink" title="累积分布函数"></a>累积分布函数</h2><p>可以看出，计算可信度的方法至关重要，他决定了阈值的选择以及一个节点是否需要被加入黑名单。</p><p>指数分布的 “累积分布函数 “有很多实现方法，原论文中建议用高斯分布来近似分布，但cassandra的开发者实验认为指数分布的效果更优秀，这也可能和cassandra使用gossip协议而不是点对点的心跳轮询有关。一般如果是点对点的心跳轮询，那么故障将遵循正态分布，但由于gossip从端点 A 到端点 B 是以随机间隔发送的，它们很可能构成一个泊松过程。</p><p>cassandra曾对计算步骤做过<a href="https://issues.apache.org/jira/browse/CASSANDRA-2597">说明</a>，我们再次梳理理解一下：</p><p>假设我们的服务发现方为A，服务注册方为B。P_later表示一个端点 B 不可用的可能性。t 表示 A 收到 B 发出最后一条 Syn&#x2F;Ack&#x2F;Ack2 gossip 报文以来所经过的时间：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">P_later</span><span class="params">(t)</span></span> = <span class="number">1</span> - <span class="built_in">F</span>(t)</span><br></pre></td></tr></table></figure><p>其中，F(t) 是事件分布的 CDF。对于指数分布，CDF 为 1 - e^(-Lt)，其中 L 是速率参数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P_later(<span class="name">t</span>) = <span class="number">1</span> - (<span class="number">1</span> - e^(<span class="name">-Lt</span>))</span><br></pre></td></tr></table></figure><p>速率参数 L 的最大似然估计值为 1&#x2F;mean，其中 mean 是实际数据中观察到的时间的算术平均值（此处为来自端点 B 的最新流言信息到达时间）。我们预计这个速率参数会随时间变化，因此有必要存储到达时间间隔的滑动窗口。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P_later(<span class="name">t</span>) = <span class="number">1</span> - (<span class="number">1</span> - e^(<span class="name">-t/mean</span>))</span><br></pre></td></tr></table></figure><p>Cassandra 的原作者到此为止。Apache Cassandra 开发人员做了明显的简化：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">P_later</span><span class="params">(t)</span></span> = e^(-t/mean)</span><br></pre></td></tr></table></figure><p>但我要进一步看看 P_later 在 phi 计算中的使用方式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">phi</span><span class="params">(t)</span></span> = <span class="built_in">-log10</span>(<span class="built_in">P_later</span>(t))</span><br></pre></td></tr></table></figure><p>展开为</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">phi</span>(<span class="built_in">t</span>) = -<span class="built_in">log10</span>(e^(-<span class="built_in">t</span>/mean))</span><br></pre></td></tr></table></figure><p>等等，指数的对数？这不是意味着…</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">phi</span>(<span class="built_in">t</span>) = -<span class="built_in">log</span>(e^(-<span class="built_in">t</span>/mean))/ <span class="built_in">log</span>(<span class="number">10</span>) = (<span class="built_in">t</span>/mean) / <span class="built_in">log</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>所以大约</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">phi</span>(<span class="built_in">t</span>) = <span class="number">0.4342945</span> * <span class="built_in">t</span>/mean</span><br></pre></td></tr></table></figure><p>是的，对于计算机来说，计算起来比</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-<span class="number">1</span>) * <span class="keyword">Math</span>.log10(<span class="keyword">Math</span>.pow(<span class="keyword">Math</span>.e, ((-<span class="number">1</span>) * (t)/mean))))</span><br></pre></td></tr></table></figure><p>的方法简单得多。</p><p>因此，在代码中，我们看到phi的计算为：<br><img src="/../images/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88Phi-Accrual-FailureDetector/phi%E4%BB%A3%E7%A0%81.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 方案设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心跳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot扩展点:EnvironmentPostProcessor</title>
      <link href="/post/cd861ef5.html"/>
      <url>/post/cd861ef5.html</url>
      
        <content type="html"><![CDATA[<p>在一些时候，例如我们在服务中需要进行集成测试时，需要将多个模块依赖的底层数据库先拉起，才能进行完整数据通路的测试。例如业务依赖的mysql、<br>一些外部存储容器如redis、minio等。</p><p>这个时候我们就可以通过SpringBoot提供的EnvironmentPostProcessor扩展点，在环境加载后，服务启动前的阶段，对环境进行扩展。</p><blockquote><p>官网文档：<a href="https://docs.spring.io/spring-boot/docs/2.5.2/reference/htmlsingle/#howto.application.customize-the-environment-or-application-context">https://docs.spring.io/spring-boot/docs/2.5.2/reference/htmlsingle/#howto.application.customize-the-environment-or-application-context</a></p></blockquote><p>该类的作用是在SpringBoot项目启动之前自定义环境变量，可以在项目启动之前从非标准springboot配置文件中读取相关的配置并填充到springboot上下文中。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解gRPC协议(二)</title>
      <link href="/post/5a25e7f5.html"/>
      <url>/post/5a25e7f5.html</url>
      
        <content type="html"><![CDATA[<p>我们在之前的文章中介绍了gRPC协议使用的protobuf，从而定义gRPC service和具体用到的对象模型。这篇文章中，我们来具体通过gRPC来调用一个服务，看看gRPC是如何工作的。</p><p>gRPC 使用 HTTP&#x2F;2 作为传输协议。 虽然与 HTTP 1.1 也能兼容，但 HTTP&#x2F;2 具有许多高级功能：</p><p>用于数据传输的二进制组帧协议 - 与 HTTP 1.1 不同，HTTP 1.1 是基于文本的。<br>对通过同一连接发送多个并行请求的多路复用支持 - HTTP 1.1 将处理限制为一次处理一个请求&#x2F;响应消息。<br>双向全双工通信，用于同时发送客户端请求和服务器响应。<br>内置流式处理，支持对大型数据集进行异步流式处理的请求和响应。<br>减少网络使用率的标头压缩。<br>gRPC 是轻量型且高性能的。 其处理速度可以比 JSON 序列化快 8 倍，消息小 60% 到 80%。 在 Microsoft Windows Communication Foundation (WCF) 中，gRPC 的性能超过经过高度优化的 NetTCP 绑定的速度和效率。 与偏向于 Microsoft 堆栈的 NetTCP 不同，gRPC 是跨平台的。</p><p>建议在以下场景中使用 gRPC：</p><p>需要立即响应才能继续处理的同步后端微服务到微服务通信。<br>需要支持混合编程平台的 Polyglot 环境。<br>性能至关重要的低延迟和高吞吐量通信。<br>点到点实时通信 - gRPC 无需轮询即可实时推送消息，并且能对双向流式处理提供出色的支持。<br>网络受约束环境 - 二进制 gRPC 消息始终小于等效的基于文本的 JSON 消息。<br>在撰写本文时，gRPC 主要用于后端服务。 新式浏览器无法提供支持前端 gRPC 客户端所需的 HTTP&#x2F;2 控制级别。 也就是说，支持使用 .NET 的 gRPC-Web，能够从使用 JavaScript 或 Blazor WebAssembly 技术构建的基于浏览器的应用进行 gRPC 通信。 gRPC-Web 使 ASP.NET Core gRPC 应用能支持浏览器应用中的 gRPC 功能：</p><p>强类型、代码生成的客户端<br>压缩 Protobuf 消息<br>服务器流式处理</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解gRPC协议(一)Protobuf</title>
      <link href="/post/12cc1a39.html"/>
      <url>/post/12cc1a39.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是gRPC协议"><a href="#什么是gRPC协议" class="headerlink" title="什么是gRPC协议"></a>什么是gRPC协议</h1><p><a href="https://grpc.io/">gRPC</a> 是一个由Google开发的高性能开源的RPC框架，基于HTTP&#x2F;2协议标准设计，支持GO，C++，JAVA，Python等多种语言。我们之前已经介绍过了RPC框架，见<a href="https://null-528.github.io/post/b9eb0f9.html">详解RPC</a>，gRPC整体流程和RPC是完全一致的：</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/grpc%E8%B0%83%E7%94%A8.svg" alt="grpc调用"><br>gRPC使用谷歌自家开源的Protocol Buffers(protobuf)作为信息描述格式。因此我们需要先来学习一下protobuf。</p><h1 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h1><p>协议缓冲区Protobuf(Protocol Buffers)是一种免费开源的跨平台数据格式，用于序列化结构化数据。（From <a href="https://en.wikipedia.org/wiki/Protocol_Buffers">Wiki</a>）它与 JSON 或XML 类似，只是体积更小、速度更快，而且能生成本地语言绑定。</p><p>在通信管道上，protobuf 使用ASCII码，通过纯二进制的方式进行传输。由于其紧凑的数据结构，在传输数据时，能够节省带宽、提高传输性能，但同时也意味着相比 JSON 和 XML 这种字符文本形式，protobuf丧失了可读性，也就是说，如果没有外部规范文件.proto，就无法知道字段的名称、含义或完整数据类型。</p><p>由于上述特性，protobuf非常适合用于高效RPC传输的场景。发送端和接收端使用相同的一份.proto文件，发送端将数据通过.proto文件中定义的格式对数据进行序列化，然后发送给接收端，接收端通过.proto文件对数据进行反序列化。</p><h1 id="protobuf详解"><a href="#protobuf详解" class="headerlink" title="protobuf详解"></a>protobuf详解</h1><p>例如我们有一个后缀为 .proto 的普通文本文件，里面定义了Field对象的相关字段：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> xxx.proto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;xxx.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Field</span> &#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> metric = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> field = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Type</span> &#123;</span><br><span class="line">        IMAGES = <span class="number">0</span>;</span><br><span class="line">        WEB = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字段</th><th>含义</th></tr></thead><tbody><tr><td align="center">syntax</td><td>protobuf的版本，目前支持proto2和proto3，默认为proto2。在我们这篇文章中的case都使用proto3版本</td></tr><tr><td align="center">package</td><td>用来声明包避免命名冲突，如果使用的是JAVA，那么等效于java_package。</td></tr></tbody></table><blockquote><p>在不同的语言中都有不同option来定制化一些内容，例如java还有：</p><ul><li>java_multiple_files：默认为false。设置是否生成多个文件，如果为true，那么每个message对象都会生成一个.java文件。</li><li>java_outer_classname：在单文件的情况下，设置生成的.java文件名称，即多个message对象的外部类名称。如果没有设置的话，会将.proto文件名的驼峰写法作为文件名。</li><li>java_generate_equals_and_hash：默认false，设置是否生成equals和hashCode方法。</li><li>java_generic_services：默认false，设置是否生成泛型服务。</li></ul><p> 其他语言中也有对应的option，例如：</p><ul><li>csharp_namespace：设置C#的命名空间。</li><li>go_package：设置Go的包名。</li><li>py_generic_services：默认false，设置是否开启Python的泛型服务。</li><li>ruby_package：设置Ruby的包名。</li></ul><p>需要注意，proto2和proto3具体option是有区别的，具体可以参考[官方文档](<a href="https://developers.google.com/protocol-buffers/docs/proto%EF%BC%89">https://developers.google.com/protocol-buffers/docs/proto）</a></p></blockquote><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>很多标准的简单数据类型供字段可用，常用的有double、float、uint32、uint64、bool、string、bytes、uint32、uint64、enum以及其他在文件中定义的message类型。</p><ul><li>int32、int64：如果负数指定这两个类型编码效率较低。负数应该使用下面的类型。</li><li>sint32、sint64：对负数会进行ZigZag编码提高编码效率。</li><li>fixed32、fixed64：总是4字节和8字节</li><li>sfixed32、sfixed64：总是4字节和8字节</li><li>enum：枚举类型，对应的字段编号必须从0开始，其对应的枚举值会作为默认值。</li></ul><p>因为采用Varint编码4个字节能表示的最大数字就是228-1了，超过这个值就需要5个字节来表示。因此对于大于228-1的数，采用固定长度fixed32或者fixed64的效率会更高。</p><h2 id="字段编号"><a href="#字段编号" class="headerlink" title="字段编号"></a>字段编号</h2><p>需要给每一个字段赋予一个整数作为编号，用来唯一指定二进制中的field。传输的时候只会使用这个编号，具体的信息，如字段名称、类型等，是通过传输双方共有的.proto文件来确定的。这样就节省了一些带宽空间，也避免了不同语言中表示字段类型大小不同的冲突。</p><p>所以编号一旦正式使用就不支持修改,<strong>否则就相当于删除了这个字段，然后创建了一个相同类型但不同编号的新字段</strong>。就算真的要删除这个字段，这个字段在使用时忽略即可，不要删除，否则可能导致新增字段不小心重复编号。</p><p>使用限制：</p><ol><li>给定的编号在该对象的所有字段中必须是唯一的。</li><li>字段编号 19,000 至 19,999 保留给协议缓冲区实现。如果在报文中使用了这些保留字段编号，协议缓冲区编译器将发出报警。<blockquote><p>一般我们会从1开始依次递增+1编号，因为较低的字段编号传输时中占用的空间较少。例如，字段编号范围为 1 至 15 的字段编号只需一个字节进行编码。16 至 2047 范围内的字段编号需要两个字节。</p></blockquote></li></ol><h2 id="字段规则"><a href="#字段规则" class="headerlink" title="字段规则"></a>字段规则</h2><p>目前支持optional和required、repeated。</p><ul><li>optional表示该字段非必填，可以为空。</li><li>required表示该字段必填，不能为空。</li><li>repeated表示该字段可以重复多次，包括零次，相当于数组。</li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>上面代码已经体现，protobuf的数据结构格式（schema）叫做message，它表示定义一个对象,一个消息(message)是包含一系列类型字段的k-v对。想象我们需要将这些数据序列化为二进制串，那么需要知道每个字段对应的起止位置、名称和对应的值。</p><p>所以<strong>报文的二进制版本会将字段编号作为键，解码端通过.proto文件来确定每个字段的名称和声明类型。</strong>即以T-L-V（Tag - Length - Value）表示单个字段field，最终将所有数据拼接成一个紧凑的字节流：</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/TLV.webp" alt="protobuf使用的TLV"></p><h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>先来看Tag，它由两部分组成，最后整体通过Varints编码：</p><ul><li>field_number：字段编号，见1.1.2节。</li><li>wire_type：protobuf编码类型，目前protobuf定义了6种，见上表（其中Start group和End group已经被废弃）。序列化和反序列化时会选择对应的编码方式，编码对象为最终的Value。</li></ul><p>tag至少占用一个1字节，如果field_number大于15，那么需要多占用2个字节。其中最高位用于Varint编码保留，确认下一个字节是否需要。另外wire_type占用4个bit，field_number占用剩余的bit。</p><h3 id="Length-Value"><a href="#Length-Value" class="headerlink" title="Length &amp; Value"></a>Length &amp; Value</h3><p>length表示Value的长度，但并不是必填，可以根据message使用的数据类型来判断value长度。<strong>但如果tag中选择wire_type为Length-delimited，那么表示value是变长的数据类型，如string，所以length是必填的。</strong></p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>前文提过，protobuf现在支持的编码方式只有4种，分别是Varint、Fixed32、Fixed64和Length-delimited。对于文本类型，直接根据ASCII码转为二进制即可，但对数字类型稍微复杂些：</p><h3 id="Varint"><a href="#Varint" class="headerlink" title="Varint"></a>Varint</h3><p>Varint编码方式是最常用的数字编码方式，举个例子：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int32 a = 251;</span><br><span class="line"></span><br><span class="line">数字251的二进制补码表示为：</span><br><span class="line">0000 0000 0000 0000 0000 0000 1111 1011</span><br><span class="line"></span><br><span class="line">使用varint编码：</span><br><span class="line">1.以7位1组单位逆序：</span><br><span class="line">111 1011 000 0001 0000 0000 0000 0000 00</span><br><span class="line"></span><br><span class="line">2.7位1组，第一位高位为msb(most significant bit)表示是否需要下一个字节，这里第一个字节需要下一个字节，故第一个字节补高位为1。第二个字节不需要第三个字节了，故第二个字节补高位为0</span><br><span class="line">1111 1011 0000 0001 0000 0000 0000 0000 00</span><br><span class="line"></span><br><span class="line">故数字251的varint编码为：</span><br><span class="line">1111 1011 0000 0001</span><br><span class="line"></span><br><span class="line">十六进制表示为：</span><br><span class="line">0xFB01</span><br></pre></td></tr></table></figure><p>可以看到，每个字节中的最高位都需要保留，因此4个字节最多可以表示2^28-1，超过这个数就需要增加一个字节，降低一定编码效率。</p><h3 id="ZigZag"><a href="#ZigZag" class="headerlink" title="ZigZag"></a>ZigZag</h3><p>另外，容易想到，如果要表示的负数，原来的最高位是符号位，这样就发生了冲突，或者占用2个bit就进一步压缩了能表示的数字范围，会有更大的几率需要增加额外字节，因此Varint编码方式只适用于正数，对于负数，需要使用ZigZag编码，<strong>有符号整数映射到无符号整数，然后再使用 Varints 编码。</strong>映射关系为：</p><ul><li>Zigzag(n) &#x3D; (n &lt;&lt; 1) ^ (n &gt;&gt; 31),  n为sint32时</li><li>Zigzag(n) &#x3D; (n &lt;&lt; 1) ^ (n &gt;&gt; 63),  n为sint64时</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint32 a = -1;</span><br><span class="line"></span><br><span class="line">-1的二进制编码：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">n &lt;&lt; 1后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line"></span><br><span class="line">n &gt;&gt; 31后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111</span><br><span class="line"></span><br><span class="line">故(n &lt;&lt; 1) ^ (n &gt;&gt; 31)后为：</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1110</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1111----两行执行不进位的半加操作</span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">故:Zigzag(-1) = 1;</span><br></pre></td></tr></table></figure><h2 id="反序列化解析"><a href="#反序列化解析" class="headerlink" title="反序列化解析"></a>反序列化解析</h2><p>那么对于一整个message结构体:</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个根据这个.proto文件生成的二进制串：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">十六进制：</span><br><span class="line">0a06 5374 6576 656e</span><br><span class="line"></span><br><span class="line">二进制表示为：</span><br><span class="line">00001010 00000110 01010011 01110100 01100101 01110110 01100101 01101110</span><br></pre></td></tr></table></figure><p>先分析前两个字节，在这个case中即tag和length</p><p><img src="/../images/%E8%AF%A6%E8%A7%A3gRPC%E5%8D%8F%E8%AE%AE/deserialize.png"></p><p>再来看value，即后面的6个字节，分别对应ASCII码：<code>83 116 101 118 101 110</code>，对照ASCII码表得到的字符串为： <code>Steven</code>。</p><h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><p>除了message之外，proto文件中还可以定义service，用来定义远程调用的方法：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">Computer</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ping (Empty) <span class="keyword">returns</span> (ServerStatus) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> compute (stream ComputeRequest) <span class="keyword">returns</span> (stream ComputeResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的service中定义了两个方法，我们分别来看一下：</p><h2 id="简单rpc"><a href="#简单rpc" class="headerlink" title="简单rpc"></a>简单rpc</h2><p>ping()方法，参数为Empty，返回值为ServerStatus。具体这两个对象需要在.proto文件中去详细定义。整个过程和平常的函数调用一样。</p><h2 id="流式rpc"><a href="#流式rpc" class="headerlink" title="流式rpc"></a>流式rpc</h2><p>注意到第二个方法，compute()，参数为stream ComputeRequest，返回值为stream ComputeResponse。通过在参数和返回值前加上stream关键字，表示这是一个流式rpc。</p><ul><li>如果只在入参部分使用stream关键字，说明是一个客户端流式RPC，即客户端使用流将一个消息序列发送给服务端，然后服务端返回一个响应；</li><li>反过来，如果只在返回值部分使用stream关键字，说明是一个服务端流式RPC，即客户端在发送请求后，使用流从服务端获取响应，直到流中没有其他消息为止。</li><li>如果同时使用stream关键字，则表示双向流式RPC，即客户端和服务端都使用流将消息序列发送和接收。这两个流是独立操作的，因此客户端和服务器可以按任意顺序发送和接收消息。比如：服务器可以在写入响应前等待接收到所有的请求消息，或者可以交替读取和写入消息，或者以任何顺序读取和写入。</li></ul><h1 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h1><p>可以看到，message这种结构体在传输时，需要一次性加载到内存中进行解析，因此只适合用于传输几兆字节的小数据块，如果报文太大，应该考虑其他的方法，比如流式传输。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解RPC</title>
      <link href="/post/b9eb0f9.html"/>
      <url>/post/b9eb0f9.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>在最早的时候，进程只能获取自己栈帧内的数据，例如有2个进程，两者是无法数据通信的。为了解决这个问题，出现了本地进程间通信IPC（Inter-Process Communication）技术，通过如共享内存，管道等手段，来交换数据。但后来业务逐渐复杂，磁盘、CPU等资源逐渐达到瓶颈，人们开始考虑将多台计算机组成一个集群来提高服务的吞吐能力，这就是分布式。</p><p>RPC（Remote Procedure Call），即远程程序调用，可以理解为RPC是将进程间通信的范围从单机扩大到了一个共享网络中，这样不同服务间调用方法像同一服务间调用本地方法一样，而不需要调用者了解底层网络技术的协议。如cassandra集群节点接通信，以及SpringCloud 微服务中各个服务之间的通信。</p><p>RPC 现在所指的概念也有些模糊，一般来说我们将其理解为一种request-response的网络传输思想，但在wiki等一些网站上，rpc也可以狭义地理解为一种协议，并且需要通过stub等动态代理来实现消息传输。</p><h1 id="RPC协议模型"><a href="#RPC协议模型" class="headerlink" title="RPC协议模型"></a>RPC协议模型</h1><p>这里介绍在wiki等网站<strong>狭义</strong>定义的RPC协议模型：<br><img src="/../images/%E8%AF%A6%E8%A7%A3RPC/rpc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpeg" alt="rpc调用"><br>整个过程可以分为以下几个阶段：</p><ol><li>客户机调用本地的Stub，将参数传递进去。</li><li>Stub将参数marshall（打包）到消息中。这个过程包括将参数标准化的过程。</li><li>Stub将消息传递给传输层，再由传输层发送到远程服务器机器。</li><li>服务器的Stub收到消息后，存根对参数进行unmarshall（解包），然后根据参数调用本地服务。</li><li>服务器服务完成调用后，将结果参数返回给服务器Stub，服务器Stub再将结果参数标准化并marshall（打包）到消息中。</li><li>服务器Stub将消息传递给传输层，传输层再发送给客户端Stub。</li><li>客户端Stub解析参数，将结果返回给调用者。</li></ol><p>在上面的流程中，看上去两个进程是1对1同步阻塞的，但实际上rpc并没有限制异步调用，可以选择异步来提高并发。</p><blockquote><p>这里用Stub存根来指代远程服务的本地代理程序或者软件，它是客户端和应用程序的中间层，用于处理一些调用细节如负责封装请求、解析响应、处理网络通信等。例如在java中，Stab就是通过动态代理技术实现的。</p><p>Stub一般都是RPC框架自动生成的，开发者不需要关心。</p></blockquote><h1 id="RPC系统"><a href="#RPC系统" class="headerlink" title="RPC系统"></a>RPC系统</h1><p>为了让不同的客户端访问服务器，人们创建了许多标准化的 RPC 框架。这些框架大多使用接口描述语言IDL(Interface description language)来让各种平台调用 RPC。IDL 文件随后可用于生成客户端与服务器之间的接口代码。目前有以下这些常见的 RPC 框架：</p><ol><li><p>gRPC：由Google开发的高性能、跨语言的RPC框架，基于HTTP&#x2F;2协议，支持多种语言，如C++, Java, Python, Go等。gRPC使用Protocol Buffers作为默认的序列化协议，支持双向流、流式处理等特性。</p></li><li><p>Apache Thrift：由Facebook开发的跨语言的RPC框架，支持多种语言，如C++, Java, Python, PHP等。Thrift使用自定义的IDL（Interface Definition Language）来定义服务接口，支持多种传输协议和序列化协议。如cassandra执行cql时使用的就是Thrift。</p></li><li><p>Apache Dubbo：由阿里巴巴开发的高性能、轻量级的RPC框架，支持多种语言，如Java, Go, Python等。Dubbo提供了丰富的功能，如负载均衡、服务注册与发现、服务治理等。但官网的性能测试数据可能并不准确，实际使用中性能表现不如gRPC，可以参考<a href="https://coolshell.cn/articles/17381.html">性能测试应该怎么做？</a></p></li></ol><h1 id="其他常见概念"><a href="#其他常见概念" class="headerlink" title="其他常见概念"></a>其他常见概念</h1><h2 id="Restful-RPC"><a href="#Restful-RPC" class="headerlink" title="Restful &amp; RPC"></a>Restful &amp; RPC</h2><p>两者不是可以放在一起比较的概念。<br>Restful，即 Representational State Transfer(表现层状态转移)，是一种设计风格，它面向资源，对接口做出了一系列要求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取所有用户： GET /users</span><br><span class="line">获取指定用户： GET /users/&#123;<span class="built_in">id</span>&#125;</span><br><span class="line">创建用户：    POST /users</span><br><span class="line">更新用户：    PUT /users/&#123;<span class="built_in">id</span>&#125;</span><br><span class="line">删除用户：    DELETE /users/&#123;<span class="built_in">id</span>&#125;</span><br></pre></td></tr></table></figure><p>从宏观来讲，RPC是一种网络通信思想，而Restful是一种API规范。RPC本身并不限制实现框架的传输协议，只要是基于传输层之上的就可以。但Restful一定都是作用于HTTP&#x2F;HTTPS协议之上的。</p><h2 id="MQTT-RPC"><a href="#MQTT-RPC" class="headerlink" title="MQTT &amp; RPC"></a>MQTT &amp; RPC</h2><p>从定义来讲，MQTT的发布订阅模式并不完全符合RPC『远程程序调用』的定义，即MQTT的接收方不会返回调用运行计算结果。笔者认为这应该是两种网络通信方式。<br>另外，从定义来讲，RPC要求调用方和被调用方必须同时存在，而MQTT是发布订阅模式，即消息的发送者不需要知道消息接收者的存在。PC是一对一，MQTT是多对一。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Java系列】代理</title>
      <link href="/post/53c8b77c.html"/>
      <url>/post/53c8b77c.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h1><p>   在编译时期无法确定需要实现哪个接口时，我们可以使用代理，在运行时创建实现一组给定接口的新类。对于编写应用程序的程序员来说这种场景比较少见，但对某些系统应用程序，代理带来的灵活性十分重要。</p><p>   总体来说，代理就是为某些对象的某种行为提供一个代理对象，并由代理对象完全控制该行为的实际执行。代理分为静态代理和动态代理两类，两者的主要区别就是代理类生成的时机，其中：</p><ul><li>静态代理：在程序运行前，创建代理类，实现代理逻辑，编译时就已经实现了，编译完成后代理类成为一个实际的class文件。</br></li><li>动态代理：在程序运行时，运用反射机制动态创建代理类，编译时没有实际的class文件，而是在运行时动态生成字节码。</br></li></ul><p>特别地，动态代理又有两种主要的实现方式，分别为：JDK 动态代理和 CGLIB 动态代理。</p><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>   当我们需要在不修改目标对象的前提下，扩展目标对象的功能，就可以使用静态代理。例如：</p><p>我们有一个接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个目标对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDao</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们的静态代理对象可以这么构建，可以看出，静态Proxy相当于将要代理的对象封装了一层，重写并嵌套使用其所有的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> implement IHello &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IHello target；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(IHello target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        ……</span><br><span class="line">        target.sayHello();</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>   假如我们要构造一个类的对象，这个类实现了1个或多个接口，但在编译时期，可能并不知道这些接口是什么，这个时候就可以使用动态代理来解决我们的问题。动态代理有两大类：JDK和CGLIB，两者最大的不同是JDK需要代理的对象是基于接口实现的，而CGLIB作为第三方代码生成的类库，没有这种需求。</p><p>   动态代理基本会代理所有的代理对象的方法,对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发，例如getClass()、clone()方法。 </p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>   JDK 动态代理就是基于 JDK 实现的代理模式，主要运用了其拦截器和反射机制，其代理对象是由 JDK 动态生成的，而不像静态代理方式写死代理对象和被代理类。JDK 代理是不需要第三方库支持的，只需要 JDK 环境就可以进行代理，使用条件：</p><ul><li>必须实现InvocationHandler</li><li>使用Proxy.newProxyInstance产生代理对象</li><li>被代理的对象必须实现一个或多个接口</li></ul><blockquote><p>使用 JDK 动态代理的五大步骤：</br><br>1.通过实现InvocationHandler接口来定义自己的InvocationHandler</br><br>2.通过Proxy.getProxyClass获得动态代理类</br><br>3.通过反射机制获得代理类的构造方法，方法签名为getConstructor(InvocationHandler.class)</br><br>4.通过构造函数获得代理对象并将自定义的InvocationHandler实例对象为参数传入</br><br>5.通过代理对象调用目标方法。</br></p></blockquote><p>  接下来，我们就按上面的 5 个步骤，写一个 JDK 动态代理的示例。</p><ul><li>PersonProxyFactory，HelloImpl的代理类，这个代理类中需要实现InvocationHandler接口的invoke方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> IHello <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> invocationHandler();</span><br><span class="line">        <span class="comment">// 传入代理目标使用的类加载器、代理目标实现的接口类型、对应的事件处理器。</span></span><br><span class="line">        <span class="keyword">return</span> (IHello) Proxy.newProxyInstance(instance.getClass().getClassLoader(), instance.getClass().getInterfaces(), invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InvocationHandler <span class="title function_">invocationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现InvocationHandler接口的invoke方法</span></span><br><span class="line">        <span class="keyword">return</span> (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(instance, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>MyProxyTest，测试类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PersonProxyFactory</span> <span class="variable">personProxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxyFactory</span>(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">        personProxyFactory.createProxy().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。它广泛地被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</p><p>还是之前的几个例子，我们实现CGLIB的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLibPersonProxyFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">IHello</span>&gt; <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CGLibPersonProxyFactory</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">createProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB HELLO WORLD !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(target, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>在动态代理的过程中，如果被代理的对象的执行方法抛错，调用方会得到InvocationTargetException类的异常，这个异常封装了实际的问题，需要使用getTargetException()方法将内容取出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】存储器</title>
      <link href="/post/947584e1.html"/>
      <url>/post/947584e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h1><p>容量：即主存最大寻址范围。如，32位微型机提供32位物理地址，即支持2^32&#x3D;4G主存空间。<br>存取时间：存储器访问时间，指启动一次存储器操作到完成该操作所用的时间。<br>存取周期：值连续启动两次独立的存储器操作（例如连续两次读取操作）所需要的最小时间。通常存储周期略大于存取时间。<br>但相比与高速的CPU，主存的读取还是慢了非常多。由于指令存储在主存，因此可能出现存储速度跟不上CPU处理指令和数据的速度。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="RAM易失性存储器"><a href="#RAM易失性存储器" class="headerlink" title="RAM易失性存储器"></a>RAM易失性存储器</h2><p>RAM又称读写存储器，CPU缓存、电脑缓存和手机内存基本都属于RAM。RAM根据能否长时间保存数据，又分为动态RAM和静态RAM：<br><strong>动态RAM</strong>：通过MOS电容是否存储电荷表达0&#x2F;1，在断开电源后，电容会放电，因此存储的数据在断电后丢失。现在主要有以下几种类型：</p><ul><li>SDRAM(Synchronous DRAM，同步动态RAM)：理论速度能够和CPU同步，刚开始可以和CPU同频刷新从而减少等待时间，后来这个频率不断提升，现在有很多都是超频；</li><li>DDRSDRAM(Dual Data Rate SDRAM，双倍速率动态RAM)：即DDR内存，在时钟上升和下降沿上各传输一次信号，因此传输速率为传统SDRAM的两倍；</li><li>RDRAM(Rambus DRAM)：Inter本来强力推广的存储类型，引入了精简指令集，是全新的结构体系，但是市场化不如DDR内存。<br><strong>静态RAM</strong>：通过触发器门电路表达0&#x2F;1，需要使用6个或者更多的晶体管构成特殊电路来表达1个bit。触发器断电后，就会失去存储的数据。<br><strong>静态RAM集成度低，功耗大，速度快；动态RAM集成度高，功耗小，价格低廉，因此适合用于大容量存储</strong>。</li></ul><h2 id="ROM非易失性存储器"><a href="#ROM非易失性存储器" class="headerlink" title="ROM非易失性存储器"></a>ROM非易失性存储器</h2><p>固态硬盘、U盘、买手机说的32G、64G存储空间就属于ROM。<br>ROM即叫Read Only Memory，在厂商制造时写入数据，然后不可更改了（熔丝已经被焊死了），例如BIOS就在ROM上，早期的CD、DVD也都属于ROM。</p><blockquote><p><strong>但实际上现在主要使用的ROM也有很多种可写的</strong>：<br><strong>PROM(Programmable ROM)可编程只读寄存器</strong>，如一些英语学习机，厂商造出存储器后卖给学习机工厂，学习机工程师再只写入一次数据，然后就只读了。也就是说，熔丝刚开始是全部接通的，用户可以按需求断开部分熔丝（也就是我们说的烧到板子上）。<br><strong>EPROM(Erasable programmable ROM)可擦可编程只读存储器</strong>，通过紫外线擦除电荷，编程次数不受限制。<br><strong>EEPROM(Electrically erasable programmable ROM)电子式可擦可编程只读存储器</strong>，通过电擦除电荷，但重复改写次数有限，大概10w上下。<br>**Flash Memory(闪存)**。电擦除且次数不受限制，具有大容量、非易失、低价格的特点。闪存属于EEPROM的一种，也是电可擦除，但我们说EEPROM时一般是说非闪存的普通EEPROM。<br>我们现在手机内存，用的都是可重复写入的ROM了。</p></blockquote><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><p>我们知道，CPU的处理速度是非常快的，普通内存在CPU面前都是弟弟，相差近2个数量级，因此工程师在CPU和内存中间增加了一层cache，通过缓存命中的方式，将热数据存储到cache中，进一步减短CPU读写时间，充分发挥CPU计算性能。<br>因此现在计算机中的主要存储设备包括了缓存-主存-辅存这样一个三级结构，容量依次增大，速度依次减慢。各层之间速度会差至少一个数量级。<br>主存需要存储正在执行的程序和大量数据（CPU寄存器也会存储一小部分）。在如今这种计算机有大量输入输出设备的前提下，为了快速传输数据，支持存储器与输入输出设备之间直接传输数据，这种技术叫DMA直接存储器存储。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>一般在我们计算机中会存在三级缓存：L1、L2、L3，速度依次递减，但仍然比主存快。这三层缓存一般都是静态RAM：之前介绍过，是速度最快，但成本相对较高的一种存储器。</p><h3 id="L1缓存"><a href="#L1缓存" class="headerlink" title="L1缓存"></a>L1缓存</h3><p>每个CPU会有一块自己的专属L1缓存，容量较小，一般在16KB到128KB之间。进一步可以分为指令缓存（Instruction Cache）和数据缓存（Data Cache），分别用于存储指令和数据。这种划分可以加快处理器执行指令和访问数据的速度。</p><h3 id="L2缓存"><a href="#L2缓存" class="headerlink" title="L2缓存"></a>L2缓存</h3><p>可以是每个CPU独享，也可以是多核CPU共享，容量稍大一些，一般在256KB到8MB之间。L2缓存为L1缓存提供支持，存储更多的数据和指令，减少处理器访问主内存的频率，从而提高整体性能。</p><h3 id="L3缓存"><a href="#L3缓存" class="headerlink" title="L3缓存"></a>L3缓存</h3><p>多核CPU共享，容量最大，一般在4MB到50MB之间。L3缓存进一步减少处理器对主内存的依赖。它存储最近使用的数据块，减少多核处理器之间的数据交换延迟。</p><p>注意，虽然我们一般都认为有三层缓存，但各个技术公司也在不断发展新的技术来进一步提高存储性能，不一定所有电脑都是三层缓存！</p><blockquote><p>Inter系列经常使用这种结构，但例如Apple Macbook Inter系列可以通过sysctl -a命令找到：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a</span><br><span class="line"><span class="symbol">hw.cachelinesize:</span> <span class="number">64</span>      <span class="meta"># CacheLine size：64 Byte </span></span><br><span class="line"><span class="symbol">hw.l1icachesize:</span> <span class="number">32768</span>    <span class="meta"># L1 Instruction Cache：32KB </span></span><br><span class="line"><span class="symbol">hw.l1dcachesize:</span> <span class="number">32768</span>    <span class="meta"># L1 Data Cache：32KB </span></span><br><span class="line"><span class="symbol">hw.l2cachesize:</span> <span class="number">262144</span>    <span class="meta"># L2 Cache：256KB </span></span><br><span class="line"><span class="symbol">hw.l3cachesize:</span> <span class="number">4194304</span>   <span class="meta"># L3 Cache：4MB</span></span><br></pre></td></tr></table></figure><p>而在Apple Macbook pro M3看到的却是L1-L2两层架构：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a</span><br><span class="line"><span class="symbol">hw.cachelinesize:</span> <span class="number">128</span>     <span class="meta"># CacheLine size：128 Byte </span></span><br><span class="line"><span class="symbol">hw.l1icachesize:</span> <span class="number">131072</span>   <span class="meta"># L1 Instruction Cache：128 KB</span></span><br><span class="line"><span class="symbol">hw.l1dcachesize:</span> <span class="number">65536</span>    <span class="meta"># L1 Data Cache：64KB</span></span><br><span class="line"><span class="symbol">hw.l2cachesize:</span> <span class="number">4194304</span>   <span class="meta"># L2 Cache：4MB</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 可能和M3芯片提出的动态缓存有关，另外有一种高性能模式下的缓存分配，目前没有看到相关技术解析</span></span><br><span class="line"><span class="symbol">hw.perflevel0.l1icachesize:</span> <span class="number">196608</span>    </span><br><span class="line"><span class="symbol">hw.perflevel0.l1dcachesize:</span> <span class="number">131072</span> </span><br><span class="line"><span class="symbol">hw.perflevel0.l2cachesize:</span> <span class="number">16777216</span> </span><br><span class="line"><span class="symbol">hw.perflevel1.l1icachesize:</span> <span class="number">131072</span> </span><br><span class="line"><span class="symbol">hw.perflevel1.l1dcachesize:</span> <span class="number">65536</span></span><br><span class="line"><span class="symbol">hw.perflevel1.l2cachesize:</span> <span class="number">4194304</span></span><br></pre></td></tr></table></figure><p>Cache是由很多个 Cache line 组成的。Cache line 是 cache 和 RAM 交换数据的最小单位，通常为 64 Byte。当 CPU 把内存的数据载入 cache 时，会把临近的共 64 Byte 的数据一同放入同一个Cache line，因为空间局部性，临近的数据在将来被访问的可能性大。</p></blockquote><p>那么CPU读取数据&#x2F;指令的顺序就是这样的：先去L1，命中就返回，否则去L2找，命中就返回，否则去L3找，命中就返回，否则去内存找。在L1中没有的热数据就从底向上一层一层搬上来，根据LRU等原则进行替换。</p><p>Martin和Mike的 QCon presentation 演讲中给出了一些缓存未命中的消耗数据，也就是从CPU访问不同层级数据的时间概念:</p><table><thead><tr><th align="left">从CPU到</th><th align="left">大约需要的CPU时钟周期</th><th align="left">大约需要的时间</th></tr></thead><tbody><tr><td align="left">主存</td><td align="left"></td><td align="left">约60-80ns</td></tr><tr><td align="left">QPI 总线传输(between sockets, not drawn)</td><td align="left"></td><td align="left">约20ns</td></tr><tr><td align="left">L3 cache</td><td align="left">约40-45 cycles</td><td align="left">约15ns</td></tr><tr><td align="left">L2 cache</td><td align="left">约10 cycles</td><td align="left">约3ns</td></tr><tr><td align="left">L1 cache</td><td align="left">约3-4 cycles</td><td align="left">约1ns</td></tr><tr><td align="left">寄存器</td><td align="left">1 cycle</td><td align="left"></td></tr></tbody></table><h3 id="主存（内存）"><a href="#主存（内存）" class="headerlink" title="主存（内存）"></a>主存（内存）</h3><p>到了内存，一般就会采用动态RAM了，速度快，但是比cache又慢一些。我们说的电脑内存条就是这个部分。没有保存的文档、正在运行的程序，在没有保存时都是在主存里的。</p><h3 id="辅存"><a href="#辅存" class="headerlink" title="辅存"></a>辅存</h3><p>辅存都是非易失性存储器，也就是我们之前说的ROM。<br>目前流行的辅存主要分为两类：磁表面存储器和光存储器。主要技术指标是存储密度、存储容量和寻址时间。除此以外当然还有其他的一些指标，例如数据传输率、误码率、成本等。</p><h4 id="磁表面存储器"><a href="#磁表面存储器" class="headerlink" title="磁表面存储器"></a>磁表面存储器</h4><ol><li>磁盘：包括我们使用的硬盘和软盘，当然软盘现在使用的人很少了。我们常用的HHD机械硬盘就是一个密封的盒子封装一个可旋转磁盘、电机、一条带着读写磁头的机械臂。磁盘每分钟转速可以达到几千甚至上万，来满足用户硬盘读写的需求。现在硬盘一般使用串行ATA接口，数据1次传输1位，但比并行ATA更快。SATA接口平均传输速率能达到6G bit&#x2F;s</li><li>磁带：SSD固态硬盘是使用了Flash Memory闪存芯片的存储器，</li></ol><h4 id="存储密度"><a href="#存储密度" class="headerlink" title="存储密度"></a>存储密度</h4><p>存储密度是指单位长度或单位面积磁表面所存储的二进制信息量。</p><h5 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h5><p>磁道：磁盘表面的同心圆磁化轨道，这个轨道通过磁化轨迹记录信息。<br>道密度：沿着磁盘半径方向单位长度的磁道数量<br>道距：为了避免道和道之间磁性干扰需要保持距离，之间距离的长度<br>存储密度：可以用道密度和位密度标识，也可以用两者的乘机——面密度表示。</p><h5 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h5><p>磁道：沿着磁带长度方向的磁道。<br>存储密度：主要用位密度表示。</p><h4 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h4><p>存储容量指磁表面存储器能存储的二进制信息总量，一般单位是字节。<br>磁盘存储器存储时，需要先格式化，然后才能开始存储用户要记录的信息。有格式化容量和非格式化容量两个指标：<br>格式化容量（可用容量）：按照某种特定的记录格式所能存储的信息总量，也就是用户真正可以使用的容量。<br>非格式化容量（总容量）：磁记录表面可以利用的磁化单元总数。格式化容量一般是非格式化容量的60%~70%。</p><h4 id="寻址时间"><a href="#寻址时间" class="headerlink" title="寻址时间"></a>寻址时间</h4><h5 id="磁盘-1"><a href="#磁盘-1" class="headerlink" title="磁盘"></a>磁盘</h5><p>磁盘存储器采用了直接存取的方式，因此寻址时间包括2个部分：</p><ol><li>磁头寻找目标磁道所需要的时间T1；</li><li>找到磁道后，磁头等待要读写的区域旋转到它下方所需要时间T2;</li></ol><p>因为磁道都是同心圆，因此t1最大时间是从最里面的磁道寻址最外面的磁道，最小时间是相邻磁道的寻址，我们取平均值作为平均寻道时间T1’&#x3D;(T1max + T1min)&#x2F;2；<br>同样地，磁头等不同区段花费的时间也不一样，我们同样取平均值作为平均等待时间T2’&#x3D;(T2max + T2min)&#x2F;2<br>那么我们就可以得到平均寻址时间T &#x3D; T1’ + T2’ &#x3D; (T1max + T1min)&#x2F;2 + (T2max + T2min)&#x2F;2</p><p>一般情况下，磁盘寻址时间在10ms左右，平均等待时间是磁盘转半圈的时间。</p><h5 id="磁带-1"><a href="#磁带-1" class="headerlink" title="磁带"></a>磁带</h5><p>磁带存储器采用顺序存储，因此寻址时间没有寻道的部分，只有磁带移动到对应区域所在的时间。这个时间对应磁盘上信息的周长，因此整体寻址时间更长。</p><h4 id="数据传输率"><a href="#数据传输率" class="headerlink" title="数据传输率"></a>数据传输率</h4><p>数据传输率是磁表面存储器在单位时间内与主机之间传输数据的位数或字节数叫做数据传输率。</p><h4 id="误码率"><a href="#误码率" class="headerlink" title="误码率"></a>误码率</h4><p>误码率是衡量磁表面存储器出错概率的参数，等于从辅存读出时，出错位数和读出总位数之比。</p><h4 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h4><p>一般我们会计算存储的位价格，即价格除以容量。所有存储设备中，磁表面存储器和光盘存储器位价格都是低的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机组成原理】概论</title>
      <link href="/post/60fe0c4f.html"/>
      <url>/post/60fe0c4f.html</url>
      
        <content type="html"><![CDATA[<h1 id="信息的表达"><a href="#信息的表达" class="headerlink" title="信息的表达"></a>信息的表达</h1><blockquote><p>思考: 我们为什么需要计算机？它是用来解决什么问题的？</p><p>本质上就是我们采用可操作的电路，来运输、计算和记录信息。为了实现这个目标，我们需要思考如何将信息通过合理的形式，在电路上进行表达（甚至后续进行的进行检测和修复）。</p></blockquote><p>我们需要将概念落地工程化。首先，怎样在电路中表达信息？<br>正如电路有连通和断开两种情况一样，我们用1和0来表达这两种信息。在足够小又足够多的电路中，我们就能有大量的0和1。正如英文有26个字母，只要我们将信息和字母排列组合做出映射（单词表），那么我们就能够表达丰富的语言一样，0和1作为2个基础字母，在计算机世界中也就能表达各种各样的含义。再加上一些逻辑原件，那么就可以进行相关的计算了！</p><h1 id="计算机的出现"><a href="#计算机的出现" class="headerlink" title="计算机的出现"></a>计算机的出现</h1><blockquote><p>比如第一台电子计算机ENIAC（electronic numerical integrator and computer）电子数值积分计算机，是1943-1946美国宾夕法尼亚大学研制的，有<strong>18000多个电子管，1500个继电器，重达30吨，占地约170平方米，耗电140kw</strong>，每秒能计算5000次加法。这台计算机是美国陆军部资助研发的，二战期间用于辅助新武器弹道计算。 </p><p>它的缺点是只能存20个长度为10位的十进制数，并且需要人工改线路连接来编排程序，计算准备时间大大超过实际使用时间，故障排查也很费精力。<br>我们常常将计算机故障称为bug，也是由于这个阶段中电路和原件可能由于小飞虫进度出现故障。</p></blockquote><h2 id="计算机基础架构"><a href="#计算机基础架构" class="headerlink" title="计算机基础架构"></a>计算机基础架构</h2><p>与此同时冯诺依曼和莫尔小组合作研制EDVAC计算机，特点是不需要人工修改线路，而是将指令（程序）存储起来，计算机按照指令顺序执行，每步骤的计算结果放入存储器中。其后在相当长的一段时间内开发的计算机都和EDVAC计算机的方案保持一致，我们称为<strong>冯诺依曼型计算机</strong>，一般是由5个部分构成：<strong>运算器、控制器、存储器、输入设备和输出设备</strong>。<br>（1）采用二进制表达信息；<br>（2）将数据和指令都以二进制的方式存储在存储器中；<br>（3）运算器是整个机器的核心，输入输出设备与存储器件中的数据运输都是通过运算器。<br>（4）指令由操作码和地址码构成。<br>（5）指令在存储器中按照执行顺序存放，由指令计数器（即程序计算器PC）指明要执行指令所在的存储单元地址，一般按照顺序递增，但可按运算结果或外界条件改变。<br>我们说的CPU，实际上包含了运算器和控制器。</p><blockquote><p>计算机的整体架构就比较明确了，接下来同样的，我们要解决的是工程落地问题，为了实现这些内容，我们会问出以下问题：<br>（1）怎样用二进制表达信息，如何用最小的成本表达最多的信息？<br>（2）什么是存储器，它是怎样存储二进制信息的，以及如何在有电&#x2F;断电情况下继续保持信息？<br>（3）运算器有哪些，分别有什么作用？<br>（4）指令是怎样执行的？PC如何选择要执行的指令，在执行故障时如何中断程序并给出信息？<br>（5）如何在运行过程中允许监听外部指令，做到对用户指令进行反馈？</p></blockquote><p>带着上面的问题，后面的文章也大概分为了四章，带着我的理解尽量解释。在这个过程中不可避免地会涉及到其他材料、数字逻辑、信息论内容，我们会简单提一下，如果要研究清除这一个个问题真的会花费不少的精力。</p><h1 id="计算机的发展"><a href="#计算机的发展" class="headerlink" title="计算机的发展"></a>计算机的发展</h1><p>我们一般根据计算机使用的物理器件来划分电子计算机发展史（注意电子计算机之前还有卡片机，在卡片上打孔），一般划分为这5个阶段，相邻阶段之间可能有部分时间重叠。</p><h2 id="电子管计算机时代（1940是-1950s）"><a href="#电子管计算机时代（1940是-1950s）" class="headerlink" title="电子管计算机时代（1940是~1950s）"></a>电子管计算机时代（1940是~1950s）</h2><p>1940s第一台电子计算机ENIAC由于军事需求研制，二战结束后美国IBM公司崛起，1954年开始推出IBM650小型机，1958年IBM709大型机是IBM公司性能最高的最后一台电子管计算机。</p><h2 id="晶体管计算机时代（1950s-1960s）"><a href="#晶体管计算机时代（1950s-1960s）" class="headerlink" title="晶体管计算机时代（1950s~1960s）"></a>晶体管计算机时代（1950s~1960s）</h2><p>晶体管和电子管（真空管）都是电信号放大的元器件，晶体管出现更晚一些，是1947年贝尔实验室的肖克利团队造出了第一个晶体管，比电子管体积更小，寿命更长，价格更便宜，功耗更低。<br>电子管是通过热电子发射阴阳极之间的电场来控制电流的，为了避免热损耗，单个晶体管的发热材料需要套在一个真空内壳里，这就决定了晶体管的体积不会太小，并且也更容易坏。而现代1个5纳米的芯片上甚至可以有百亿个晶体管，因此晶体管基本已经取代了电子管的地位。<br>1960~1964年CDC公司研制了大型高速计算机系统CDC6600，深受美国和西欧各原子能、宇宙、航空、气象研究和大学的欢迎。1969年的CDC7600计算速度更是达到了每秒千万次浮点运算。</p><h2 id="集成电路计算机时代（1960s-1970s）"><a href="#集成电路计算机时代（1960s-1970s）" class="headerlink" title="集成电路计算机时代（1960s~1970s）"></a>集成电路计算机时代（1960s~1970s）</h2><p>集成电路可以理解为最早的芯片雏形。将多个晶体管、电容、电阻在硅芯片上互联，相比晶体管，体积、功耗、成本进一步下降，因此计算机的体积进一步缩小了，也在市场上开始进一步流通小型机。<br>如IBM360系统，型号有小中大三种，运算速度也是从每秒几千次到每秒百万次。</p><h2 id="大规模集成电路计算机时代（1970s-1980s）"><a href="#大规模集成电路计算机时代（1970s-1980s）" class="headerlink" title="大规模集成电路计算机时代（1970s~1980s）"></a>大规模集成电路计算机时代（1970s~1980s）</h2><p>在半导体晶体管后，人们又发明了半导体存储器替代磁芯存储器，著名的摩尔定律就是这个时候提出的。1971年，Intel4004芯片问世，小型机的性能进一步提升，更广泛地应用于各种高精尖行业中。<br>同时家用计算机也开始兴起，1977年Apple推出了Apple II微机，1981年IBM公司推出了IBM PC。</p><h2 id="超大规模集成电路计算机时代（1980s-now）"><a href="#超大规模集成电路计算机时代（1980s-now）" class="headerlink" title="超大规模集成电路计算机时代（1980s~now）"></a>超大规模集成电路计算机时代（1980s~now）</h2><p>目前，高性能微处理器芯片所含的晶体管数量突破亿级，Apple的A16芯片更是集成160亿晶体管。智能手机等更小型设备也进入了人们的生活，从而形成了互联网出现的基本前提。</p><p>现在的计算机也不仅仅用于单纯数据计算，还有很多软件服务，因此我们补充一下计算机系统结构：</p><p><img src="/../images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.jpg" alt="计算机整体架构"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【开发工具】Markdown语法</title>
      <link href="/post/3c50d03d.html"/>
      <url>/post/3c50d03d.html</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Markdown 由 John Gruber 和 Aaron Swartz 于 2004 年创建，目标是创造一种web文本格式，尽可能方便人们阅读和写作。但起初它的设计主要针对一些简单日常的使用场景，并支持用户通过内联html来支持未涵盖到的语法，见<a href="https://daringfireball.net/projects/markdown/syntax">Markdown基本语法</a>。后来一些个人和组织开始通过添加其他元素来扩展基本语法，很多的Markdown处理器使用的都是拓展后的语言，例如Typora 使用的是<a href="https://github.github.com/gfm/">GitHub Flavored Markdown(GFM)</a>。</p><blockquote><p>John Gruber（1973-？） 是一个美国宾夕法尼亚州的技术博主，也是苹果公司的狂热粉丝，后来通过全职运行他的独立博客<a href="https://daringfireball.net/">Daring Fireball</a>，和有声杂志The talk show，分享他的技术见解和苹果产品的最新消息和点评。</p></blockquote><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>通过不同个数的『#』来设置标题，最多支持六级标题。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br><span class="line">####### 不支持七级标题</span><br></pre></td></tr></table></figure><p>其中，一级和二级标题还有一种写法：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">一级标题</span></span><br><span class="line"><span class="section">===================</span></span><br><span class="line"></span><br><span class="line"><span class="section">二级标题</span></span><br><span class="line"><span class="section">--------------------</span></span><br></pre></td></tr></table></figure><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>一般段落，通过换行来创建即可。在idea中可以通过setting-&gt;editor-&gt;general-&gt;soft wrap来设置全局自动换行。有需要强制换行的，通过在行尾添加<code>&lt;/br&gt;</code>来强制换行。</br><br>另外，段落<strong>不支持</strong>使用空格或tab来缩进。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>通过<code>&gt;</code>来进行块引用，支持嵌套。</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">这是一层引用</span></span><br><span class="line">&gt;&gt; 这是二层引用（后面空一行表示结束第一层引用）</span><br><span class="line"><span class="meta prompt_">&gt;</span> </span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">回到第一层引用</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">### 可以添加*标题*</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">- 和其他元素</span></span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这是一层引用</p><blockquote><p>这是二层引用</p></blockquote><p>回到第一层引用</p><h3 id="可以添加标题"><a href="#可以添加标题" class="headerlink" title="可以添加标题"></a>可以添加标题</h3><ul><li>和其他元素，但是是否渲染以及渲染效果取决于使用的解析器。</li></ul></blockquote><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>无序列表通过<code>-</code>、<code>+</code>或<code>*</code>来创建，支持嵌套。有序列表通过数字加<code>.</code>来创建，支持嵌套和相互嵌套。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是无序列表</span><br><span class="line"><span class="bullet">-</span> 无序1</span><br><span class="line"><span class="bullet">    -</span> 嵌套1</span><br><span class="line"><span class="bullet">+</span> 无序2</span><br><span class="line"><span class="bullet">*</span> 无序3</span><br><span class="line">这是有序列表</span><br><span class="line"><span class="bullet">1.</span> 有序1</span><br><span class="line"><span class="bullet">   1.</span> 嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)</span><br><span class="line"><span class="bullet">      -</span> 无序和有序可以相互嵌套</span><br><span class="line"><span class="bullet">2.</span> 有序2</span><br></pre></td></tr></table></figure><p>效果：</br><br>这是无序列表</p><ul><li>无序1<ul><li>嵌套1</li></ul></li></ul><ul><li>无序2</li></ul><ul><li>无序3</li></ul><blockquote><p>一般来说，同一个列表中最好不要混用不同的分隔符，否则有些解析器可能会识别混乱造成渲染错误。</p></blockquote><p></br>这是有序列表</p><ol><li>有序1<ol><li>嵌套i(渲染时使用的序号不一定为数字，和使用的解析器有关。可能使用罗马数字如i或者字母如a等)<ul><li>无序和有序可以相互嵌套</li></ul></li></ol></li><li>有序2</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>通过反引号『&#96;』来创建行内代码，不支持嵌套。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`hello world!`</span></span><br></pre></td></tr></table></figure><p>效果：<code>hello world!</code><br/><br>一般情况下我们都使用反斜杠<code>\</code>进行转义，但特别地，如果要对反引号进行转义，需要通过双反引号。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">``Use `code` in your Markdown file.``</span><br><span class="line">`` `hello world!` ``</span><br></pre></td></tr></table></figure><p>效果：<code>Use `code` in your Markdown file.</code> <code>`hello world!`</code> </p><p>通过前后2个『&#96;&#96;&#96;』来创建封闭的代码块，在起始的三个”&#96;”后可以表明使用的语言（小写），来进行语法高亮。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHello</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法高亮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>使用<code>*</code>或<code>_</code>来设置斜体，使用<code>**</code>或<code>__</code>来设置加粗，使用<code>***</code>或<code>___</code>来设置斜体加粗，使用<code>~~</code>来设置删除线。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*斜体*</span></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="emphasis">__加粗__</span></span><br><span class="line"><span class="strong">***斜体加粗**</span>*</span><br><span class="line"><span class="emphasis">___斜体加粗__</span>_</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果：<br><em>斜体</em><br><em>斜体</em><br><strong>加粗</strong><br><strong>加粗</strong><br><em><strong>斜体加粗</strong></em><br><em><strong>斜体加粗</strong></em><br><del>删除线</del></p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="外部url直接引用"><a href="#外部url直接引用" class="headerlink" title="外部url直接引用"></a>外部url直接引用</h2><p>通过&lt;&gt;可以直接创建外部引用链接。如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:<span class="comment">//baidu.com/&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<a href="https://baidu.com/">https://baidu.com/</a>。</br><br>如果需要添加说明，可以通过<code>[说明](url)</code>来创建外部链接，同样地，可以对链接字体进行设置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>](<span class="link">https://baidu.com/</span>)</span><br><span class="line"><span class="strong">**[<span class="string">加粗</span>](<span class="link">https://baidu.com/</span>)**</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line"><span class="emphasis">*[<span class="string">粗斜体</span>](<span class="link">https://baidu.com/</span>)*</span>.</span><br><span class="line">~~[<span class="string">删除线</span>](<span class="link">https://baidu.com/</span>)~~.</span><br><span class="line">[<span class="string">`行内代码`</span>](<span class="link">https://baidu.com/</span>).</span><br></pre></td></tr></table></figure><p>效果：<br><a href="https://baidu.com/">百度</a><br><strong><a href="https://baidu.com/">加粗</a></strong>.<br><em><a href="https://baidu.com/">斜体</a></em>.<br><em><a href="https://baidu.com/">粗斜体</a></em>.<br><del><a href="https://baidu.com/">删除线</a></del>.<br><a href="https://baidu.com/"><code>行内代码</code></a>.</p><h2 id="参考链接引用"><a href="#参考链接引用" class="headerlink" title="参考链接引用"></a>参考链接引用</h2><p>例如文章可能需要多次引用同一个链接，可以通过这种方式实现复用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"><span class="selector-tag">B</span>处内容<span class="selector-attr">[baidu]</span><span class="selector-attr">[百度]</span>&lt;/br&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[百度]</span>: https://baidu.com/ <span class="string">&quot;注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别&quot;</span></span><br></pre></td></tr></table></figure><p>效果：<br>A处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a><br>B处内容<a href="https://baidu.com/" title="注意这个链接一定要和上文分段（换行），如果只是分行（&lt;/br&gt;）可能无法识别">baidu</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>通过<code>![说明](图片地址)</code>来创建图片。其中图片地址支持url和本地图片路径。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[可能不存在的网络照片.jpeg]</span>(https://cdn.imalan.cn/img/post/<span class="number">2934349</span>b033b5bb5a19efc7233d3d539b700bcf5.jpg)</span><br><span class="line">!<span class="selector-attr">[rpc调用]</span>(../images/详解RPC协议/rpc调用流程.jpeg)</span><br></pre></td></tr></table></figure><p>效果：<br><img src="https://cdn.imalan.cn/img/post/2934349b033b5bb5a19efc7233d3d539b700bcf5.jpg" alt="可能不存在的网络照片.jpeg"></p><p><img src="/../images/%E8%AF%A6%E8%A7%A3RPC/rpc%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpeg" alt="rpc调用"></p><blockquote><p>不同的 Markdown 应用程序在处理 URL 的方式可能存在不同，<strong>因此推荐使用编码后的url</strong>。例如如果添加的链接中有空格，为了兼容起见，最好使用 %20 （空格的编码形式）来代替空格。</p></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>通过<code>|</code>来设置表格，通过<code>---</code>来设置表头。其中，表头可以通过<code>:--:</code>来设置居中，<code>:--</code>来设置居左，<code>---:</code>来设置居右。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 姓名 | 年龄 | 性别 |</span><br><span class="line">| :--- | ---: | :--: |</span><br><span class="line">| 张三 | 18 | 男 |</span><br></pre></td></tr></table></figure><p>效果：</br></p><table><thead><tr><th align="left">姓名</th><th align="right">年龄</th><th align="center">性别</th></tr></thead><tbody><tr><td align="left">张三</td><td align="right">18</td><td align="center">男</td></tr></tbody></table><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>通过连续3个以上的相同符号：<code>*</code>、<code>-</code>、<code>_</code>来创建分割线。分割线的效果同样取决于使用的解析器。在实践中，最好在分隔线的前后均添加空白行。</br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">分割线1</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">分割线2</span></span><br><span class="line"><span class="string">___</span></span><br><span class="line"><span class="string">分割线3</span></span><br></pre></td></tr></table></figure><p>效果：</p><hr><p>分割线1</p><hr><p>分割线2</p><hr><p>分割线3</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开发经验】IDEA修改使用的JDK版本</title>
      <link href="/post/2052380.html"/>
      <url>/post/2052380.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在实际开发中偶尔会碰到需要切换JDK版本的情况，就我自己而言，大范围修改JDK版本有两次：</p><p>一次是由于我是21年开始使用MAC M1作为主力开发，当时Open JDK兼容性不太好，因此选择了zulu JDK。但不同JDK的实现有些差异，切换后可能会发现部分类丢失等情况导致编译异常。在Open JDK兼容M1版本后，果断将所有项目保持统一切换回Open JDK。</p><p>还有一次就是在开发的产品的JDK版本升级，公司要求所有产品都升级到JDK11以上，因此JDK8的老产品都进行了相关升级。</p><p>有时会记不清具体需要修改哪些地方导致遗漏，因此写这篇文章记录一下。</p><ol><li>修改项目编译使用的JDK版本<br>首先在主菜单IntelliJ IDEA&#x2F;preferences（windows版本对应全局settings界面）中，找到Build,Execution,Deployment -&gt; Compiler，修改编译使用的版本，然后Apply。</li></ol><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/1.png"></p><ol start="2"><li>添加项目JDK版本路径<br>如果是一个全新版本的JDK，那么需要在主菜单的File -&gt; Project Structure中，找到Project Settings -&gt; Platform Settings -&gt; SDKs中，添加JDK名称和对应路径。</li></ol><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/2.png"></p><ol start="3"><li>修改项目整体默认使用的JDK版本+路径<br>还是在Project Structure中，找到Project Settings -&gt; Project，修改JDK 和对应的language level。</li></ol><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/3.png"></p><ol start="4"><li>修改每个模块使用的JDK版本<br>这部分可以按需调整，比如某些模块使用JDK8，而其他模块使用JDK11。还是在Project Structure中，找到Project Settings -&gt; Modules，修改source中的JDK 和对应dependencies的language level。</li></ol><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/4.1.png"></p><p><img src="/../images/IDEA%E4%BF%AE%E6%94%B9%E4%BD%BF%E7%94%A8%E7%9A%84JDK%E7%89%88%E6%9C%AC/4.2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA,JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开发经验】IDEA调式技巧</title>
      <link href="/post/f3b3a2f5.html"/>
      <url>/post/f3b3a2f5.html</url>
      
        <content type="html"><![CDATA[<h1 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h1><p>当我们需要数据一个新的服务代码，例如了解cassandra的启动流程，如果只看代码很容易遗漏一些细节，这个时候可以通过远程调试，一步步来跟踪代码，查看服务运行情况。</p><ol><li><p>调整debug configuration，添加远程debug参数<br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/1.jpg"><br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/2.jpg"><br>需要修改的参数：<br>①Host: 如果是本地启动的服务，可以填写localhost，否则填写服务ip<br>②Port: 调试端口，注意不要和服务器端的端口冲突。<br>另外注意公司可能做了端口拦截或防火墙，要保证本地服务是能访问到调试的ip+port。</p></li><li><p>在启动服务的入口添加参数<br>例如cassandra，是通过bin&#x2F;cassandra脚本，执行launch_server方法启动的。我们在脚本中将上面remote JVM参数添加到java启动命令中。其中需要将断点syspend改为y，否则不会在我们打的断点处停下来。<br> 完整命令类似于：</p> <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=trans<span class="keyword">port</span>=dt_socket,server=y,suspend=y,address=5005</span><br></pre></td></tr></table></figure><p>在脚本中修改后类似于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="variable">$NUMACTL</span> <span class="string">&quot;<span class="variable">$JAVA</span>&quot;</span> <span class="variable">$JVM_OPTS</span> -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=y,address=5005 <span class="variable">$cassandra_parms</span> -<span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$CLASSPATH</span>&quot;</span> <span class="variable">$props</span> <span class="string">&quot;<span class="variable">$class</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>启动服务，等待debug连接<br><img src="/../images/IDEA%E8%B0%83%E5%BC%8F%E6%8A%80%E5%B7%A7/3.jpg"><br>现在IDEA中点击debug按钮，监听远程服务断点，然后我们执行脚本启动服务，然后就可以在IDEA中调试服务了。</p></li><li><p>本地测试作为远程服务<br>当遇到一些集成测试，可能发生case间影响的时候，也可以尝试用这样的方法来调试。唯一不同的就是我们启动单测的方式：<br>对于mvn，可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean verify -Pjacoco -Dtest.env.runningMode=multi  -Dtest=&quot;&quot;  </span><br></pre></td></tr></table></figure><p>对于gradle，则可以执行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./gradlew</span> <span class="params">--info</span> :&#123;submodule&#125;<span class="function">:test</span> <span class="params">--tests=</span><span class="string">&quot;&quot;</span> -Dorg.gradle.debug=<span class="literal">true</span> <span class="params">--debug-jvm</span></span><br></pre></td></tr></table></figure><p>例如，单跑1个case：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --info :iot-tsdb-data-unit-test:test --tests=<span class="string">&quot;xxx.MysqlConnectorJTest&quot;</span> --debug-jvm</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h2 id="my-frequently-used-commands"><a href="#my-frequently-used-commands" class="headerlink" title="my frequently used commands"></a>my frequently used commands</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post <span class="string">&#x27;postname&#x27;</span></span><br><span class="line">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>hexo项目需要迁移&#x2F;换电脑时，直接将项目打包复制到新电脑上即可，node_modules部分文件可能由于网络下载会被拦截，<br>mac可在隐私与安全中选择不拦截即可正常使用</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
